<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A New Python AVIF Encoding Option: ImageCodecs | JacksBlog</title>
<meta name=keywords content="avif encoding,python avif,imagecodecs"><meta name=description content="Encode high bit-depth NumPy arrays directly to AVIF in Python using ImageCodecs and libavif, with HDR, lossless, and quality/speed options."><meta name=author content="Miaosen Zhou"><link rel=canonical href=https://jackchou.top/en/posts/imagecodecs-avif/><link crossorigin=anonymous href=/assets/css/stylesheet.0836d676002390eb2d95514c792f0c95c72e254f79fa3685f789cce0b04d9243.css integrity="sha256-CDbWdgAjkOstlVFMeS8MlccuJU95+jaF94nM4LBNkkM=" rel="preload stylesheet" as=style><link rel=icon href=https://jackchou.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jackchou.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jackchou.top/favicon-32x32.png><link rel=apple-touch-icon href=https://jackchou.top/apple-touch-icon.png><link rel=mask-icon href=https://jackchou.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://jackchou.top/posts/imagecodecs-avif/><link rel=alternate hreflang=en href=https://jackchou.top/en/posts/imagecodecs-avif/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://cdn.jsdelivr.net><meta property="og:url" content="https://jackchou.top/en/posts/imagecodecs-avif/"><meta property="og:site_name" content="JacksBlog"><meta property="og:title" content="A New Python AVIF Encoding Option: ImageCodecs"><meta property="og:description" content="Encode high bit-depth NumPy arrays directly to AVIF in Python using ImageCodecs and libavif, with HDR, lossless, and quality/speed options."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-10T23:00:00+08:00"><meta property="article:modified_time" content="2025-12-21T00:41:45+08:00"><meta property="article:tag" content="Display"><meta property="article:tag" content="HDR"><meta property="article:tag" content="AVIF"><meta property="article:tag" content="Image"><meta property="og:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp"><meta name=twitter:title content="A New Python AVIF Encoding Option: ImageCodecs"><meta name=twitter:description content="Encode high bit-depth NumPy arrays directly to AVIF in Python using ImageCodecs and libavif, with HDR, lossless, and quality/speed options."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts üå≥","item":"https://jackchou.top/en/posts/"},{"@type":"ListItem","position":2,"name":"A New Python AVIF Encoding Option: ImageCodecs","item":"https://jackchou.top/en/posts/imagecodecs-avif/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A New Python AVIF Encoding Option: ImageCodecs","name":"A New Python AVIF Encoding Option: ImageCodecs","description":"Encode high bit-depth NumPy arrays directly to AVIF in Python using ImageCodecs and libavif, with HDR, lossless, and quality/speed options.","keywords":["avif encoding","python avif","imagecodecs"],"articleBody":"Background Requirements Images processed and generated in Python are usually stored as NumPy arrays, and writing these arrays out to files is the final step of the pipeline. In the past, the most common approach was using PIL to encode them as JPEG. As needs around HDR, high bit-depth, and higher compression ratios have grown, I started looking for ways to encode numerical data directly into AVIF images.\nlibavif and libheif Almost all related libraries are Python bindings for libavif or libheif. In practice, you can absolutely export a JPEG or a high bit-depth TIFF first, then call a compiled libavif directly for encoding, passing in all parameters (quality, speed, colour configuration). If all you need is image compression, there‚Äôs really no need to route back through Python.\nSo the core requirement is actually to find a good Python binding for libavif that supports passing various parameters, and if the API is elegant, even better.\nLimited options AVIF encoding in Python has seen some progress. PIL added official AVIF support in version 11.3.0, but both reading and writing are limited to 8-bit, and there is no interface for passing parameters. The following two plugins can read/write high bit-depth images and accept parameters.\nBefore PIL 11.3.0, the way to use PIL for AVIF encoding was the pillow-avif-plugin plugin, where advanced parameters could be passed in via keyword arguments.\nAnother choice with PIL is pillow-heif, which is a binding for libheif. After version 1.0.0 it removed AVIF support, with the developer‚Äôs reasoning being that PIL already has native AVIF support. The last version with AVIF support is 0.22.0, and advanced parameters also need to be passed via keyword arguments.\nImageIO and OpenImageIO both provide read/write support for various image formats, but they don‚Äôt seem to support high bit-depth and advanced parameters (or more accurately, their APIs are a bit complex and I haven‚Äôt fully figured them out yet, but it‚Äôs either unsupported or a hassle).\nA new choice: ImageCodecs ImageCodecs is another library that provides read/write support for various image formats, using libavif as the backend for AVIF.\nIts strengths lie in its very clean API design. It previously did not support passing colour space parameters, but support was added in the 2025.11.11 release. (If you need something, feel free to ‚Äúreach out‚Äù reasonably in the Issue.)\nNote: Please manually specify the encoding speed and thread count. You can use the default value 6 from libavif‚Äôs sample routine avifenc as a reference for speed. Otherwise, the default parameters may result in single-threaded encoding at the slowest speed, causing a 4K resolution image to take several minutes.\nThe library wraps some parameters, and you can also pass integer values directly. Definitions for colour primaries and transfer functions can be found in H.273.\nAdditionally, when using 10 or 12-bit depth, the uint16 data type should be employed without value stretching. For example, the maximum value for a 10-bit image should be 1023, while 12-bit images should use 4095.\nfrom imagecodecs import avif_version, avif_encode, AVIF import numpy as np print(AVIF.available) print(avif_version()) array = np.ones((100, 100), dtype=np.uint16) * 1023 # 10-bit, BT.2020 with BT.2100 PQ transfer function encoded: bytes = avif_encode( array, level=AVIF.QUALITY.DEFAULT, # 0-100 speed=AVIF.SPEED.FASTEST, # 0-10 bitspersample=10, primaries=AVIF.COLOR_PRIMARIES.BT2020, transfer=AVIF.TRANSFER_CHARACTERISTICS.PQ, numthreads=8, ) with open(\"output.avif\", \"wb\") as f: f.write(encoded) All of its image formats follow similar function naming. You just need to check availability and version, then call encode or decode.\nWatch out for the flashbang (sorry, might be too late).\nPeak RGB and white in BT.2020 primaries with the BT.2100 PQ transfer function, 10-bit, encoded with ImageCodecs.\n","wordCount":"592","inLanguage":"en","image":"https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp","datePublished":"2025-11-10T23:00:00+08:00","dateModified":"2025-12-21T00:41:45+08:00","author":{"@type":"Person","name":"Miaosen Zhou"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jackchou.top/en/posts/imagecodecs-avif/"},"publisher":{"@type":"Organization","name":"JacksBlog","logo":{"@type":"ImageObject","url":"https://jackchou.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jackchou.top/en/ accesskey=h title="JacksBlog (Alt + H)">JacksBlog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://jackchou.top/ title=‰∏≠Êñá aria-label=‰∏≠Êñá>‰∏≠Êñá</a></li></ul></div></div><ul id=menu><li><a href=https://jackchou.top/en/posts/ title="Posts üå≥"><span>Posts üå≥</span></a></li><li><a href=https://jackchou.top/en/photos/ title="Photos üì∑"><span>Photos üì∑</span></a></li><li><a href=https://jackchou.top/en/tags/ title="Tags üè∑Ô∏è"><span>Tags üè∑Ô∏è</span></a></li><li><a href=https://jackchou.top/en/about/ title="About üòº"><span>About üòº</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A New Python AVIF Encoding Option: ImageCodecs</h1><div class=post-meta><span title='2025-11-10 23:00:00 +0800 +0800'>2025.11.10</span>&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://jackchou.top/posts/imagecodecs-avif/>‰∏≠Êñá</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#background aria-label=Background>Background</a><ul><li><a href=#requirements aria-label=Requirements>Requirements</a></li><li><a href=#libavif-and-libheif aria-label="libavif and libheif">libavif and libheif</a></li></ul></li><li><a href=#limited-options aria-label="Limited options">Limited options</a></li><li><a href=#a-new-choice-imagecodecs aria-label="A new choice: ImageCodecs">A new choice: ImageCodecs</a></li></ul></div></details></div><div class=post-content><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><h3 id=requirements>Requirements<a hidden class=anchor aria-hidden=true href=#requirements>#</a></h3><p>Images processed and generated in Python are usually stored as NumPy arrays, and writing these arrays out to files is the final step of the pipeline. In the past, the most common approach was using PIL to encode them as JPEG. As needs around HDR, high bit-depth, and higher compression ratios have grown, I started looking for ways to encode numerical data directly into AVIF images.</p><h3 id=libavif-and-libheif>libavif and libheif<a hidden class=anchor aria-hidden=true href=#libavif-and-libheif>#</a></h3><p>Almost all related libraries are Python bindings for libavif or libheif. In practice, you can absolutely export a JPEG or a high bit-depth TIFF first, then call a compiled libavif directly for encoding, passing in all parameters (quality, speed, colour configuration). If all you need is image compression, there‚Äôs really no need to route back through Python.</p><p>So the core requirement is actually to find a good Python binding for libavif that supports passing various parameters, and if the API is elegant, even better.</p><h2 id=limited-options>Limited options<a hidden class=anchor aria-hidden=true href=#limited-options>#</a></h2><p>AVIF encoding in Python has seen some progress. PIL added official AVIF support in version 11.3.0, but both reading and writing are limited to 8-bit, and there is no interface for passing parameters. The following two plugins can read/write high bit-depth images and accept parameters.</p><p>Before PIL 11.3.0, the way to use PIL for AVIF encoding was the <code>pillow-avif-plugin</code> plugin, where advanced parameters could be passed in via keyword arguments.</p><p>Another choice with PIL is <code>pillow-heif</code>, which is a binding for libheif. After version 1.0.0 it removed AVIF support, with the developer‚Äôs reasoning being that PIL already has native AVIF support. The last version with AVIF support is 0.22.0, and advanced parameters also need to be passed via keyword arguments.</p><p>ImageIO and OpenImageIO both provide read/write support for various image formats, but they don‚Äôt seem to support high bit-depth and advanced parameters (or more accurately, their APIs are a bit complex and I haven‚Äôt fully figured them out yet, but it‚Äôs either unsupported or a hassle).</p><h2 id=a-new-choice-imagecodecs>A new choice: ImageCodecs<a hidden class=anchor aria-hidden=true href=#a-new-choice-imagecodecs>#</a></h2><p><a href=https://github.com/cgohlke/imagecodecs>ImageCodecs</a> is another library that provides read/write support for various image formats, using libavif as the backend for AVIF.</p><p>Its strengths lie in its very clean API design. It previously did not support passing colour space parameters, but support was added in the 2025.11.11 release. (If you need something, feel free to ‚Äúreach out‚Äù reasonably in the <a href=https://github.com/cgohlke/imagecodecs/issues/131>Issue</a>.)</p><p>Note: Please manually specify the encoding speed and thread count. You can use the default value 6 from <code>libavif</code>&rsquo;s sample routine <code>avifenc</code> as a reference for speed. Otherwise, the default parameters may result in single-threaded encoding at the slowest speed, causing a 4K resolution image to take several minutes.</p><p>The library wraps some parameters, and you can also pass integer values directly. Definitions for colour primaries and transfer functions can be found in H.273.</p><p>Additionally, when using 10 or 12-bit depth, the <code>uint16</code> data type should be employed without value stretching. For example, the maximum value for a 10-bit image should be 1023, while 12-bit images should use 4095.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> imagecodecs <span style=color:#f92672>import</span> avif_version, avif_encode, AVIF
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(AVIF<span style=color:#f92672>.</span>available)
</span></span><span style=display:flex><span>print(avif_version())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>array <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>ones((<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>), dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint16) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1023</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 10-bit, BT.2020 with BT.2100 PQ transfer function</span>
</span></span><span style=display:flex><span>encoded: bytes <span style=color:#f92672>=</span> avif_encode(
</span></span><span style=display:flex><span>    array,
</span></span><span style=display:flex><span>    level<span style=color:#f92672>=</span>AVIF<span style=color:#f92672>.</span>QUALITY<span style=color:#f92672>.</span>DEFAULT, <span style=color:#75715e># 0-100</span>
</span></span><span style=display:flex><span>    speed<span style=color:#f92672>=</span>AVIF<span style=color:#f92672>.</span>SPEED<span style=color:#f92672>.</span>FASTEST,   <span style=color:#75715e># 0-10</span>
</span></span><span style=display:flex><span>    bitspersample<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>    primaries<span style=color:#f92672>=</span>AVIF<span style=color:#f92672>.</span>COLOR_PRIMARIES<span style=color:#f92672>.</span>BT2020,
</span></span><span style=display:flex><span>    transfer<span style=color:#f92672>=</span>AVIF<span style=color:#f92672>.</span>TRANSFER_CHARACTERISTICS<span style=color:#f92672>.</span>PQ,
</span></span><span style=display:flex><span>    numthreads<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;output.avif&#34;</span>, <span style=color:#e6db74>&#34;wb&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    f<span style=color:#f92672>.</span>write(encoded)
</span></span></code></pre></div><p>All of its image formats follow similar function naming. You just need to check availability and version, then call encode or decode.</p><p>Watch out for the flashbang (sorry, might be too late).</p><p><img alt="bt2020 pq test by imagecodecs" loading=lazy src=https://img.jackchou.top/jack-img/2025/11/7e50ba86eb4697f2055b7b5b0763cca9.avif></p><p>Peak RGB and white in BT.2020 primaries with the BT.2100 PQ transfer function, 10-bit, encoded with ImageCodecs.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jackchou.top/en/tags/display/>Display</a></li><li><a href=https://jackchou.top/en/tags/hdr/>HDR</a></li><li><a href=https://jackchou.top/en/tags/avif/>AVIF</a></li><li><a href=https://jackchou.top/en/tags/image/>Image</a></li></ul><nav class=paginav><a class=prev href=https://jackchou.top/en/photos/matchbox-h7s-lite-roaster/><span class=title>¬´ Prev</span><br><span>The Artistic Journey of a Green Bean: DIY Coffee Roasting</span>
</a><a class=next href=https://jackchou.top/en/posts/cic33-paper/><span class=title>Next ¬ª</span><br><span>(Temp) CIC 33 Paper Demonstration</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://jackchou.top/en/>JacksBlog</a></span> ¬∑
my friends&rsquo; websites: <a href=https://zhxwu.com/>zhxwu.com</a>, <a href=https://ylqian.com/>ylqian.com</a> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/js/site.min.a576538c52b362e170acc02d53f5ce6045117863354954a8f91f10c7217d94ab.js integrity="sha256-pXZTjFKzYuFwrMAtU/XOYEUReGM1SVSo+R8QxyF9lKs="></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>