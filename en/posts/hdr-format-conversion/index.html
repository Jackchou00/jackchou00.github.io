<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>HDR Image Format Conversion | üè°JacksBlog</title>
<meta name="keywords" content="Colour">
<meta name="description" content="Conversion of HDR still image formats">
<meta name="author" content="Jack">
<link rel="canonical" href="https://jackchou.top/en/posts/hdr-format-conversion/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bb4e9ae2e440bccf3cb7d24276f41ff835376bf2c78193c51417a098608382c4.css" integrity="sha256-u06a4uRAvM88t9JCdvQf&#43;DU3a/LHgZPFFBegmGCDgsQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jackchou.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jackchou.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jackchou.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jackchou.top/apple-touch-icon.png">
<link rel="mask-icon" href="https://jackchou.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh-cn" href="https://jackchou.top/posts/hdr-format-conversion/">
<link rel="alternate" hreflang="en" href="https://jackchou.top/en/posts/hdr-format-conversion/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&family=Noto+Sans+SC:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">


<style>
#domain-migration-notice {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 12px 20px;
  text-align: center;
  z-index: 1000;
  font-size: 14px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  display: none;
}

#domain-migration-notice.show {
  display: block;
}

#domain-migration-notice .notice-content {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
}

#domain-migration-notice .notice-text {
  flex: 1;
  text-align: center;
}

#domain-migration-notice .close-btn {
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.3);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.3s;
}

#domain-migration-notice .close-btn:hover {
  background: rgba(255,255,255,0.3);
}

#domain-migration-notice a {
  color: #ffeb3b;
  text-decoration: underline;
}

body.notice-shown {
  padding-top: 60px;
}

@media (max-width: 768px) {
  #domain-migration-notice {
    padding: 10px 15px;
    font-size: 13px;
  }
  
  #domain-migration-notice .notice-content {
    flex-direction: column;
    gap: 8px;
  }
  
  body.notice-shown {
    padding-top: 80px;
  }
}
</style>

<script>
(function() {
  
  const expiryDate = new Date('2025-10-31');
  const now = new Date();
  
  if (now > expiryDate) {
    return; 
  }
  
  
  if (localStorage.getItem('domain-migration-dismissed') === 'true') {
    return;
  }
  
  
  const noticeHTML = `
    <div id="domain-migration-notice">
      <div class="notice-content">
        <div class="notice-text">
          <span class="zh-notice" style="display: none;">
            üëã ÂÜçËßÅÔºåjackchou00.icu    üöÄ Êñ∞ÁöÑÊóÖÈÄîÔºå‰ªé <a href="https://jackchou.top">jackchou.top</a> Ëµ∑Á®ã
          </span>
          <span class="en-notice" style="display: none;">
            üëã Goodbye, jackchou00.icu    üöÄ A new chapter will begin at <a href="https://jackchou.top">jackchou.top</a>
          </span>
        </div>
        <button class="close-btn" onclick="dismissNotice()">‚úï</button>
      </div>
    </div>
  `;
  
  
  document.addEventListener('DOMContentLoaded', function() {
    
    document.body.insertAdjacentHTML('afterbegin', noticeHTML);
    
    
    const isEnglish = document.documentElement.lang === 'en' || window.location.pathname.startsWith('/en/');
    const zhNotice = document.querySelector('.zh-notice');
    const enNotice = document.querySelector('.en-notice');
    
    if (isEnglish && enNotice) {
      enNotice.style.display = 'inline';
    } else if (zhNotice) {
      zhNotice.style.display = 'inline';
    }
    
    
    const notice = document.getElementById('domain-migration-notice');
    if (notice) {
      notice.classList.add('show');
      document.body.classList.add('notice-shown');
    }
  });
  
  
  window.dismissNotice = function() {
    const notice = document.getElementById('domain-migration-notice');
    if (notice) {
      notice.style.display = 'none';
      document.body.classList.remove('notice-shown');
      localStorage.setItem('domain-migration-dismissed', 'true');
    }
  };
})();
</script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dc1311d77d6840123f21aa2f8a31c84";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><meta property="og:url" content="https://jackchou.top/en/posts/hdr-format-conversion/">
  <meta property="og:site_name" content="üè°JacksBlog">
  <meta property="og:title" content="HDR Image Format Conversion">
  <meta property="og:description" content="Conversion of HDR still image formats">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-04-25T00:00:00+08:00">
    <meta property="article:modified_time" content="2025-04-25T00:00:00+08:00">
    <meta property="article:tag" content="Colour">
      <meta property="og:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp">
<meta name="twitter:title" content="HDR Image Format Conversion">
<meta name="twitter:description" content="Conversion of HDR still image formats">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts üå≥",
      "item": "https://jackchou.top/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "HDR Image Format Conversion",
      "item": "https://jackchou.top/en/posts/hdr-format-conversion/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HDR Image Format Conversion",
  "name": "HDR Image Format Conversion",
  "description": "Conversion of HDR still image formats",
  "keywords": [
    "Colour"
  ],
  "articleBody": "What is an ‚ÄúImage‚Äù? An image is essentially a ‚Äòmatrix‚Äô or an ‚Äòarray‚Äô. For example, the most common type of image might be an array with the shape (Height, Width, Channel), where the number at each position is quantised to eight bits, representing 256 different levels as an integer or floating-point number. The data stored here is generally called the code value or pixel value.\nEncoding Storing this array directly can result in a very large file, so compression methods, or ‚Äôencoding‚Äô, are needed. Encoding methods are constantly evolving. For instance, there‚Äôs JPG (JPEG) encoding, which uses techniques like chroma subsampling, Discrete Cosine Transform (DCT), and Huffman coding for compression. There‚Äôs also the highly extensible TIFF (*.tif) format, which is a container format that can internally use various lossless/lossy encoding methods like ZIP, LZW, PackBits, and even JPEG. Then there are more advanced codecs like HEIC (HEIF/HEVC) and AV1, which feature flexible partitioning structures, multi-mode intra-prediction, and more advanced entropy coding, enabling very high encoding efficiency.\nThe encoding process may introduce some loss, which is known as lossy compression. The commonly used JPG standard includes both lossless and lossy modes, although the lossless mode is rarely used. Many later encoding methods also support lossless compression‚ÄîAV1 even offers a true lossless profile. As long as one is not deliberately pursuing extreme compression ratios, the quality loss from lossy compression is actually difficult to perceive.\nAnother difference between various encoding methods is the quantisation bit depth they allow. The JPG standard supports 8-bit and 12-bit quantisation, but the 12-bit mode is also uncommon. Newer formats often support higher bit depths; for example, HEIC and AVIF can handle 10-bit or even 12-bit, while a TIFF container can hold data with 16 or even 32 bits (floating-point) per channel. This is closely related to the requirements of HDR: to avoid visible banding over a wider brightness range, higher quantisation precision is needed.\nAdditional Information A pile of numbers is meaningless on its own; we also need to know the space in which they are defined. At a minimum, the primaries, white point, and transfer function (i.e., the definition of the RGB space) must be specified.\nThis additional information tells the decoder and the system‚Äôs colour management the specific meaning of these numbers. Without it, the data is usually treated as sRGB, and if the colour space does not match the actual data, major problems will occur.\nAfter the decoding software extracts the pixel values and additional information, the colour management system converts these pixel values from a known colour space into driving values for the display, allowing them to be displayed correctly. Therefore, in theory, the code values can even be tristimulus values and linear, as long as there is corresponding additional information to define them. The images below are two PMCC colour charts tagged with the XYZ space and a linear transfer function. The pixel values in the images are directly the tristimulus values.\nThis is a tristimulus value image of a colour chart under a D65 illuminant, where values exceeding 1 have been clipped. This is actually an incorrect way of handling it; CIEXYZ in nclx requires an equal-energy white as the white point, and a Bradford CAT from an ICC profile could be used for the conversion.\nThis is the image adapted to an equal-energy white point (done by directly replacing the white point). Because it is adapted to an equal-energy white, no values will exceed 1. When displayed, the system‚Äôs colour management will perform chromatic adaptation to the display‚Äôs white point, so its appearance should be close to the background in light mode. The page background in light mode has a code value of 245.\nIf you are using iOS or iPadOS, you may not be able to see these two images. Testing on other systems has shown they are generally visible.\nAdditional information can take many forms, such as an embedded ICC profile, XML statements or nclx data stored within the image file, or it can be stored in the EXIF data.\nThis step is the most critical part of achieving an HDR effect. Once the correct transfer function is specified, the decoder can convert the code values into what is known as ‚ÄúHDR‚Äù content, which can exceed the nominal luminance of SDR.\nThere is a rather special method for implementing HDR called a Gain Map. A single file stores two images (an SDR image and a gain map) along with some corresponding additional information (specific gain coefficients, etc.). The decoder can then compute a new HDR image from the two images. Therefore, the gain map could perhaps also be considered a form of additional information.\nDisplay-Referred Linear Light When performing image format conversions, all references to linear light space should be Display-Referred. This means calculating the luminance (either brightness or absolute tristimulus values) of the image on the display after it has been shown.\nDuring decoding, the EOTF is used. During encoding, the inverse EOTF is used, not the OETF (there is a distinction for transfer functions like PQ).\nPQ or HLG Transfer Functions Similar to HDR video, changing the transfer function from Gamma or Rec. 709 to PQ or HLG can achieve the transition from SDR to HDR. For still images, the international standard ISO-22028-5 already exists.\nCanon was the first to introduce 10-bit HEIC encoding in its mirrorless cameras, using PQ as the transfer function. Sony has HLG for still images. In recent versions of ACR, the AVIF and 16-bit TIF files produced when HDR output is enabled without maximum compatibility are PQ-encoded.\nFor this type of HDR image, one simply needs to apply the correct transfer function to convert to or from linear light.\nGainmap A Gainmap is a method for implementing HDR specifically for still images. Its advantage is excellent compatibility, as it can store both SDR and HDR content simultaneously (rather than relying on dynamic metadata and a TMO) and is very friendly to display drivers.\nJPG, JXL, and AVIF can all store this format. In particular, a JPG with a Gainmap is essentially two JPG files concatenated together. Image viewers that do not support this format will simply read the first file as a standard SDR image. When sending the original image on social media, the subsequent Gainmap can be preserved. Even if the app itself does not support it, saving it to another app may still reveal the HDR effect.\nThe first large-scale application of Gainmap was likely on the OPPO Find X6 Pro. Later, Google promoted the UltraHDR format. The ISO is currently developing the ISO-21496-1 standard, and UltraHDR version 1.1 is already compatible with this standard.\nA Gainmap can be written for luminance only or for all three channels. The ‚ÄúProXDR‚Äù in the recently released OPPO Find X8 Ultra refers to a three-channel Gainmap.\nA Gainmap can be understood as a form of Supplemental Enhancement Information (SEI) or Colour Remapping Information (CRI), which records the difference between the SDR and HDR sources. Additionally, it stores the absolute luminance relationship of the Gainmap through something akin to static metadata.\nThe metadata includes: content max luminance gain (how much brighter the HDR is compared to the SDR), display max luminance gain (how much brighter the master HDR is compared to the SDR), the Gamma used for encoding the gainmap, and an optional offset.\nRegarding the content max and display max luminance gains, an example is the HDR limiter in ACR, which can limit the HDR headroom during post-production to ‚Äôn‚Äô stops. For example, if a three-stop limit is set, the maximum display gain during post-production is three stops, but the content may have a luminance gain exceeding three stops, which is simply clipped. The purpose of setting this display max luminance gain metadata is likely to restore the creative intent from the time of production.\nRegarding SDR‚Äôs Nominal Luminance Although rarely adhered to in practice, SDR actually has a specified white point luminance. For example, sRGB is 80 nits, and ITU-R BT.2035 specifies 100 nits.\nSDR content can be converted to absolute luminance based on this value, and then encoded using the inverse EOTF. More often, the nominal luminance used is 203 nits. This value originates from the recommendations for various luminance levels in ITU-R BT.2408, where diffuse white is 203 nits, but it also states that this diffuse white luminance should not be interpreted as the nominal luminance for SDR.\n",
  "wordCount" : "1400",
  "inLanguage": "en",
  "image": "https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp","datePublished": "2025-04-25T00:00:00+08:00",
  "dateModified": "2025-04-25T00:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Jack"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jackchou.top/en/posts/hdr-format-conversion/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "üè°JacksBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jackchou.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jackchou.top/en/" accesskey="h" title="üè°JacksBlog (Alt + H)">üè°JacksBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://jackchou.top/" title="‰∏≠Êñá"
                            aria-label="‰∏≠Êñá">Zh-Cn</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jackchou.top/en/posts/" title="Posts üå≥">
                    <span>Posts üå≥</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/photos/" title="Photos üì∑">
                    <span>Photos üì∑</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/tags/" title="Tags üè∑Ô∏è">
                    <span>Tags üè∑Ô∏è</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/about/" title="About üòº">
                    <span>About üòº</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      HDR Image Format Conversion
    </h1>
    <div class="post-meta"><span title='2025-04-25 00:00:00 +0800 +0800'>2025.04.25</span>&nbsp;¬∑&nbsp;Jack&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="https://jackchou.top/posts/hdr-format-conversion/">Zh-Cn</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-an-image" aria-label="What is an &ldquo;Image&rdquo;?">What is an &ldquo;Image&rdquo;?</a><ul>
                        
                <li>
                    <a href="#encoding" aria-label="Encoding">Encoding</a></li>
                <li>
                    <a href="#additional-information" aria-label="Additional Information">Additional Information</a></li></ul>
                </li>
                <li>
                    <a href="#display-referred-linear-light" aria-label="Display-Referred Linear Light">Display-Referred Linear Light</a></li>
                <li>
                    <a href="#pq-or-hlg-transfer-functions" aria-label="PQ or HLG Transfer Functions">PQ or HLG Transfer Functions</a></li>
                <li>
                    <a href="#gainmap" aria-label="Gainmap">Gainmap</a></li>
                <li>
                    <a href="#regarding-sdrs-nominal-luminance" aria-label="Regarding SDR&rsquo;s Nominal Luminance">Regarding SDR&rsquo;s Nominal Luminance</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="what-is-an-image">What is an &ldquo;Image&rdquo;?<a hidden class="anchor" aria-hidden="true" href="#what-is-an-image">#</a></h2>
<p>An image is essentially a &lsquo;matrix&rsquo; or an &lsquo;array&rsquo;. For example, the most common type of image might be an array with the shape (Height, Width, Channel), where the number at each position is quantised to eight bits, representing 256 different levels as an integer or floating-point number. The data stored here is generally called the code value or pixel value.</p>
<h3 id="encoding">Encoding<a hidden class="anchor" aria-hidden="true" href="#encoding">#</a></h3>
<p>Storing this array directly can result in a very large file, so compression methods, or &rsquo;encoding&rsquo;, are needed. Encoding methods are constantly evolving. For instance, there&rsquo;s JPG (JPEG) encoding, which uses techniques like chroma subsampling, Discrete Cosine Transform (DCT), and Huffman coding for compression. There&rsquo;s also the highly extensible TIFF (*.tif) format, which is a container format that can internally use various lossless/lossy encoding methods like ZIP, LZW, PackBits, and even JPEG. Then there are more advanced codecs like HEIC (HEIF/HEVC) and AV1, which feature flexible partitioning structures, multi-mode intra-prediction, and more advanced entropy coding, enabling very high encoding efficiency.</p>
<p>The encoding process may introduce some loss, which is known as lossy compression. The commonly used JPG standard includes both lossless and lossy modes, although the lossless mode is rarely used. Many later encoding methods also support lossless compression‚ÄîAV1 even offers a true lossless profile. As long as one is not deliberately pursuing extreme compression ratios, the quality loss from lossy compression is actually difficult to perceive.</p>
<p>Another difference between various encoding methods is the quantisation bit depth they allow. The JPG standard supports 8-bit and 12-bit quantisation, but the 12-bit mode is also uncommon. Newer formats often support higher bit depths; for example, HEIC and AVIF can handle 10-bit or even 12-bit, while a TIFF container can hold data with 16 or even 32 bits (floating-point) per channel. This is closely related to the requirements of HDR: to avoid visible banding over a wider brightness range, higher quantisation precision is needed.</p>
<h3 id="additional-information">Additional Information<a hidden class="anchor" aria-hidden="true" href="#additional-information">#</a></h3>
<p>A pile of numbers is meaningless on its own; we also need to know the space in which they are defined. At a minimum, the primaries, white point, and transfer function (i.e., the definition of the RGB space) must be specified.</p>
<p>This additional information tells the decoder and the system&rsquo;s colour management the specific meaning of these numbers. Without it, the data is usually treated as sRGB, and if the colour space does not match the actual data, major problems will occur.</p>
<p>After the decoding software extracts the pixel values and additional information, the colour management system converts these pixel values from a known colour space into driving values for the display, allowing them to be displayed correctly. Therefore, in theory, the code values can even be tristimulus values and linear, as long as there is corresponding additional information to define them. The images below are two PMCC colour charts tagged with the XYZ space and a linear transfer function. The pixel values in the images are directly the tristimulus values.</p>
<p><img alt="PMCC colour chart XYZ image under a D65 illuminant" loading="lazy" src="https://img.jackchou.top/jack-img/2025/06/10c610e35151f2c92b4e3d81065f1406.avif"></p>
<p>This is a tristimulus value image of a colour chart under a D65 illuminant, where values exceeding 1 have been clipped. This is actually an incorrect way of handling it; CIEXYZ in nclx requires an equal-energy white as the white point, and a Bradford CAT from an ICC profile could be used for the conversion.</p>
<p><img alt="PMCC colour chart XYZ image under a D65 illuminant, adapted to white point E" loading="lazy" src="https://img.jackchou.top/jack-img/2025/06/d314f9020f60ce63115708c92aaa1711.avif"></p>
<p>This is the image adapted to an equal-energy white point (done by directly replacing the white point). Because it is adapted to an equal-energy white, no values will exceed 1. When displayed, the system&rsquo;s colour management will perform chromatic adaptation to the display&rsquo;s white point, so its appearance should be close to the background in light mode. The page background in light mode has a code value of 245.</p>
<p>If you are using iOS or iPadOS, you may not be able to see these two images. Testing on other systems has shown they are generally visible.</p>
<p>Additional information can take many forms, such as an embedded ICC profile, XML statements or nclx data stored within the image file, or it can be stored in the EXIF data.</p>
<p>This step is the most critical part of achieving an HDR effect. Once the correct transfer function is specified, the decoder can convert the code values into what is known as &ldquo;HDR&rdquo; content, which can exceed the nominal luminance of SDR.</p>
<p>There is a rather special method for implementing HDR called a Gain Map. A single file stores two images (an SDR image and a gain map) along with some corresponding additional information (specific gain coefficients, etc.). The decoder can then compute a new HDR image from the two images. Therefore, the gain map could perhaps also be considered a form of additional information.</p>
<h2 id="display-referred-linear-light">Display-Referred Linear Light<a hidden class="anchor" aria-hidden="true" href="#display-referred-linear-light">#</a></h2>
<p>When performing image format conversions, all references to linear light space should be Display-Referred. This means calculating the luminance (either brightness or absolute tristimulus values) of the image on the display after it has been shown.</p>
<p>During decoding, the EOTF is used. During encoding, the inverse EOTF is used, not the OETF (there is a distinction for transfer functions like PQ).</p>
<h2 id="pq-or-hlg-transfer-functions">PQ or HLG Transfer Functions<a hidden class="anchor" aria-hidden="true" href="#pq-or-hlg-transfer-functions">#</a></h2>
<p>Similar to HDR video, changing the transfer function from Gamma or Rec. 709 to PQ or HLG can achieve the transition from SDR to HDR. For still images, the international standard ISO-22028-5 already exists.</p>
<p>Canon was the first to introduce 10-bit HEIC encoding in its mirrorless cameras, using PQ as the transfer function. Sony has HLG for still images. In recent versions of ACR, the AVIF and 16-bit TIF files produced when HDR output is enabled without maximum compatibility are PQ-encoded.</p>
<p>For this type of HDR image, one simply needs to apply the correct transfer function to convert to or from linear light.</p>
<h2 id="gainmap">Gainmap<a hidden class="anchor" aria-hidden="true" href="#gainmap">#</a></h2>
<p>A Gainmap is a method for implementing HDR specifically for still images. Its advantage is excellent compatibility, as it can store both SDR and HDR content simultaneously (rather than relying on dynamic metadata and a TMO) and is very friendly to display drivers.</p>
<p>JPG, JXL, and AVIF can all store this format. In particular, a JPG with a Gainmap is essentially two JPG files concatenated together. Image viewers that do not support this format will simply read the first file as a standard SDR image. When sending the original image on social media, the subsequent Gainmap can be preserved. Even if the app itself does not support it, saving it to another app may still reveal the HDR effect.</p>
<p>The first large-scale application of Gainmap was likely on the OPPO Find X6 Pro. Later, Google promoted the UltraHDR format. The ISO is currently developing the ISO-21496-1 standard, and UltraHDR version 1.1 is already compatible with this standard.</p>
<p>A Gainmap can be written for luminance only or for all three channels. The &ldquo;ProXDR&rdquo; in the recently released OPPO Find X8 Ultra refers to a three-channel Gainmap.</p>
<p>A Gainmap can be understood as a form of Supplemental Enhancement Information (SEI) or Colour Remapping Information (CRI), which records the difference between the SDR and HDR sources. Additionally, it stores the absolute luminance relationship of the Gainmap through something akin to static metadata.</p>
<p>The metadata includes: content max luminance gain (how much brighter the HDR is compared to the SDR), display max luminance gain (how much brighter the master HDR is compared to the SDR), the Gamma used for encoding the gainmap, and an optional offset.</p>
<p>Regarding the content max and display max luminance gains, an example is the HDR limiter in ACR, which can limit the HDR headroom during post-production to &rsquo;n&rsquo; stops. For example, if a three-stop limit is set, the maximum display gain during post-production is three stops, but the content may have a luminance gain exceeding three stops, which is simply clipped. The purpose of setting this display max luminance gain metadata is likely to restore the creative intent from the time of production.</p>
<h2 id="regarding-sdrs-nominal-luminance">Regarding SDR&rsquo;s Nominal Luminance<a hidden class="anchor" aria-hidden="true" href="#regarding-sdrs-nominal-luminance">#</a></h2>
<p>Although rarely adhered to in practice, SDR actually has a specified white point luminance. For example, sRGB is 80 nits, and ITU-R BT.2035 specifies 100 nits.</p>
<p>SDR content can be converted to absolute luminance based on this value, and then encoded using the inverse EOTF. More often, the nominal luminance used is 203 nits. This value originates from the recommendations for various luminance levels in ITU-R BT.2408, where diffuse white is 203 nits, but it also states that this diffuse white luminance should not be interpreted as the nominal luminance for SDR.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jackchou.top/en/tags/colour/">Colour</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://jackchou.top/en/">üè°JacksBlog</a></span> ¬∑ 
        my friends&rsquo; websites: <a href="https://zhxwu.com/">zhxwu.com</a>, <a href="https://ylqian.com/">ylqian.com</a> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><div style="text-align: center; margin-top: 10px; margin-bottom: 20px; width: 100%; display: flex; justify-content: center;">
    <img src="https://visitor-badge.laobi.icu/badge?page_id=jacksblog" alt="visitors" style="max-width: 120px; height: auto;" />
</div>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
