<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to Correctly Read RAW Files | üè°JacksBlog</title>
<meta name="keywords" content="Colour, ISP">
<meta name="description" content="Running fast doesn&rsquo;t guarantee a win; avoiding pitfalls is true success.">
<meta name="author" content="Jack">
<link rel="canonical" href="https://jackchou.top/en/posts/how-to-read-raw/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.556aa244931a2b8641244b3a88ba5d10d011bee5ef6cc4a8df29bb3ab8574aa9.css" integrity="sha256-VWqiRJMaK4ZBJEs6iLpdENARvuXvbMSo3ym7OrhXSqk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jackchou.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jackchou.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jackchou.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jackchou.top/apple-touch-icon.png">
<link rel="mask-icon" href="https://jackchou.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh-cn" href="https://jackchou.top/posts/how-to-read-raw/">
<link rel="alternate" hreflang="en" href="https://jackchou.top/en/posts/how-to-read-raw/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100..900&family=Sen:wght@400..800&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet"><meta property="og:url" content="https://jackchou.top/en/posts/how-to-read-raw/">
  <meta property="og:site_name" content="üè°JacksBlog">
  <meta property="og:title" content="How to Correctly Read RAW Files">
  <meta property="og:description" content="Running fast doesn‚Äôt guarantee a win; avoiding pitfalls is true success.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-28T00:00:00+08:00">
    <meta property="article:modified_time" content="2025-03-28T00:00:00+08:00">
    <meta property="article:tag" content="Colour">
    <meta property="article:tag" content="ISP">
      <meta property="og:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp">
<meta name="twitter:title" content="How to Correctly Read RAW Files">
<meta name="twitter:description" content="Running fast doesn&rsquo;t guarantee a win; avoiding pitfalls is true success.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts üå≥",
      "item": "https://jackchou.top/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to Correctly Read RAW Files",
      "item": "https://jackchou.top/en/posts/how-to-read-raw/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to Correctly Read RAW Files",
  "name": "How to Correctly Read RAW Files",
  "description": "Running fast doesn\u0026rsquo;t guarantee a win; avoiding pitfalls is true success.",
  "keywords": [
    "Colour", "ISP"
  ],
  "articleBody": "Tools for Reading RAW Data Dcraw The most famous tool for reading RAW data is undoubtedly dcraw. Dcraw can convert RAW files of various encoding formats into TIFF or PPM format.\nUsing the command line dcraw -4 -T -D file_name yields a 16-bit TIFF file that records the direct RAW values, without any processing such as demosaicing, white balancing, or black level subtraction.\nUnfortunately, dcraw‚Äôs last update was on 1 June 2018. Consequently, it no longer includes additional parameters (like white balance, colour matrices, etc.) for cameras released after that date, and even its core function of extracting RAW data may not work reliably.\nFor instance, with the lossless compressed RAW format introduced by Sony in their fourth-generation cameras (e.g., ILCE-7M4), dcraw reports a ‚Äúcannot decode file‚Äù error, even though the file extension is still .arw. In contrast, it can still decode the older uncompressed RAW format.\ndcraw.c is the core file of dcraw, consisting of over ten thousand lines of pure C code.\nRawpy/LibRaw Rawpy is a Python wrapper for LibRaw. LibRaw provides a unified interface for accessing RAW data to extract pixel values. It is based on dcraw, having refactored dcraw.c into a more modern and modular library, and has continued to be supported after dcraw ceased development.\nDifferences Between Methods and Brands Sony Uncompressed RAW Test model: ILCE-7CM2:\nThe following methods yield identical results when reading uncompressed RAW files:\nConverting with Dcraw to TIFF and then reading with OpenImageIO Reading directly with Rawpy Converting with Adobe DNG Converter and then reading with Rawpy Converting with Adobe Camera Raw and then reading with Rawpy (same as above, although the dimensions appear different when viewed in ACR) Converting with Adobe DNG Converter, then converting to TIFF with dcraw, and finally reading with OIIO The dimensions read by the above methods are (4688, 7040), which is 33,003,520 pixels, with a value range of 0-16383.\nIn practice, the DNG files converted by Adobe DNG Converter and Adobe Camera Raw are identical, so this will not be detailed further. Reading DNG files with Rawpy and dcraw is also equivalent.\nThe following method produces a different result:\nAfter converting to DNG with Capture One and then reading with Rawpy (or converting to TIFF with dcraw and then reading), the image becomes (4672, 7008) with a value range of 0-65535. The height is reduced by 16 pixels (8 from the top and 8 from the bottom), and the width is reduced by 32 pixels (12 from the left and 20 from the right). Even after cropping, there are differences compared to the other methods. Looking at the ratio (after normalising both to their respective maximums of 65535 or 16383), the maximum ratio is 1.04, the minimum is 0.95, and the average is 1.00. This alignment was performed by eye in Photoshop. Lossless Compressed RAW The principle behind Sony‚Äôs lossless compressed RAW is to first pad the data with zeros to a multiple of 512, then divide it into blocks, and finally separate it into four sub-images based on the Bayer pattern for differential and Huffman coding.\nFor lossless compressed RAW, the situation is more complex because there is currently no way to convert between uncompressed ARW and lossless compressed ARW files (if two separate shots are taken, even with tethered shooting, the resulting displacement errors would be larger than one pixel). The following are the tested scenarios:\nDcraw does not support lossless compressed RAW (as Sony introduced it after dcraw was no longer being updated). Reading the ARW with Rawpy yields dimensions of (5120, 7168). This is due to the block-based compression (a multiple of 512). Only the top-left (4688, 7040) area contains image data; the rest is filled with zeros (not the black level), and the values range from 0-16383. After converting to DNG with Adobe DNG Converter and then reading with Rawpy, the resulting dimensions are (4686, 7038), which is two pixels smaller in each dimension than the uncompressed RAW. If you crop 2 pixels from the bottom and 2 from the right of the padded image from the previous scenario, the results match perfectly, also with a range of 0-16383. Reading a DNG converted by Capture One with Rawpy also results in dimensions of (4672, 7008) and a range of 0-65535. This is again cropped by 8 pixels top/bottom, and 12 left / 20 right. After cropping the content area of the ARW read by Rawpy, the results are a close match (the average of the differences is even the same, around -5e-6, which requires further testing). Regarding DNGs from Capture One Theoretically, a codec that decodes RAW and encodes to DNG should not introduce complex errors. However, DNGs exported from Capture One not only have different dimensions but also stretch the original 14-bit data to 16-bit, and they do not perfectly match the RAW data read by other methods.\nWith the help of Gemini and DeepSeek, a more detailed analysis was conducted. Regarding the conversion from 14-bit to 16-bit, Capture One appears to perform a left bit shift by two places, which is equivalent to multiplying by 4. After left-shifting the ARW data read by Rawpy and then comparing it with the C1-exported DNG (by division and subtraction), the resulting quotient is 1.000004, and the difference is on the order of e-7. The R and B channels match perfectly; all errors come from the two G channels and are content-dependent. In some images, the maximum error in the G channels can reach up to 10%, though in most cases, it does not exceed 5%.\nBest Practices for Sony RAW In summary, the recommended approach for using Sony RAW files is to shoot in uncompressed RAW and then read them directly with Rawpy. You can use Adobe DNG Converter to conveniently convert uncompressed RAW files into lossless compressed DNGs to reduce file size without any loss. Alternatively, you can read lossless compressed RAW files with Rawpy and crop them, but be aware that converting lossless compressed RAW to DNG will result in the loss of two rows and two columns of pixels. DNG files obtained through other methods have unknown factors and should not be used.\nCanon Test model: 600D, which outputs CR2 files.\nReading with Rawpy and reading after conversion to DNG yield identical results. The image dimensions are (3516, 5344). The 142 pixels on the left and 51 pixels on the top appear to be the optical black area (the part physically masked for black level calibration), which reads out values close to the black level. The remainder is the image.\nDcraw can process files from the 600D. It reads out the part without the optical black area, which matches the cropped data from Rawpy or a DNG conversion.\nThe CR3 output from an R6 Mark II (read with Rawpy or via DNG conversion) is similar. The left 154 pixels and top 96 pixels constitute the optical black area, and there is also a white area of 8 pixels on the right.\nHasselblad Test model: X2D-100C. The camera outputs files in 3FR format.\nThe sensor in this camera is identifiable; it is highly likely the IMX-461. (Correction: It‚Äôs not just ‚Äúhighly likely‚Äù; the sensor model IMX-461BQR can be found directly within the 3FR file.)\nHasselblad has several file formats, primarily 3FR and FFF. You can convert from 3FR to FFF using the Phocus software. During conversion, you have options for adjustments and whether to use the embedded 3FR configuration, but these do not affect the resulting FFF file‚Äôs data when read by other software (e.g., it reads the same with Rawpy). Examining the file headers reveals that 3FR follows the little-endian TIFF specification (starting with 49 49 2A 00), while FFF uses the big-endian TIFF specification (starting with 4D 4D 00 2A).\nThe specification sheet for the IMX461-BQR is public. It lists total pixels as 11760x8896, effective pixels as 11664x8750, and active pixels as 11656x8742.\nReading with dcraw or Rawpy produces an image of size 11904x8842, which exceeds the sensor‚Äôs total pixel count. There is a noisy border around the edge (76px on the left, 68px on the right, 2px on the top, and none on the bottom). Further in is the optical black area (48px on the left and right, 90px on the top, and none on the bottom). The innermost part is an image of size 11664x8750. The width of the image including the black area is 11760 (equal to the total pixel width), but the height is 8840 (which is rather strange).\nBoth 3FR and FFF files can be converted to DNG. The resulting DNG has the dimensions of the inner image area and can be aligned with it, but the content is slightly different.\nCurrently, the best method for reading Hasselblad RAW files seems to be reading the 3FR with LibRaw, extracting the image area, and potentially using the optical black area for black level correction.\nFujifilm Test model: X-T5.\nFujifilm‚Äôs RAW files are rather unique because their colour filter array is not a standard Bayer pattern but an X-Trans pattern, which has a minimum repeating unit of 6x6 pixels. Fortunately, this does not affect our analysis of the raw image data itself.\nFeeding the RAF file directly into Rawpy yields an image with a width of 7872 and a height of 5196. After conversion to DNG, the width is 7728 and the height is 5152. The distribution of the extra 144 pixels in width and 44 pixels in height is as follows:\n12 pixels of image data on the left; 12 pixels of image data and 120 black pixels on the right. 16 pixels of image data and 5 black pixels at the top; 16 pixels of image data and 7 black pixels at the bottom. The pixel values in the overlapping areas are identical.\nAdditionally, Rawpy reads the raw pattern from the RAF file incorrectly, whereas the raw pattern in the DNG is correct.\nNikon To be continued\nI‚Äôve found that the return on investment for this research is extremely low, and there is still much to learn. I will pause after a preliminary investigation of Nikon files. For practical use, the recommendation is to convert files to DNG using Adobe DNG Converter and then read them with Rawpy to directly access the image content.\n",
  "wordCount" : "1712",
  "inLanguage": "en",
  "image": "https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp","datePublished": "2025-03-28T00:00:00+08:00",
  "dateModified": "2025-03-28T00:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Jack"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jackchou.top/en/posts/how-to-read-raw/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "üè°JacksBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jackchou.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jackchou.top/en/" accesskey="h" title="üè°JacksBlog (Alt + H)">üè°JacksBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://jackchou.top/" title="‰∏≠Êñá"
                            aria-label="‰∏≠Êñá">‰∏≠Êñá</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jackchou.top/en/posts/" title="Posts üå≥">
                    <span>Posts üå≥</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/photos/" title="Photos üì∑">
                    <span>Photos üì∑</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/tags/" title="Tags üè∑Ô∏è">
                    <span>Tags üè∑Ô∏è</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/about/" title="About üòº">
                    <span>About üòº</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How to Correctly Read RAW Files
    </h1>
    <div class="post-meta"><span title='2025-03-28 00:00:00 +0800 +0800'>2025.03.28</span>&nbsp;¬∑&nbsp;Jack&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="https://jackchou.top/posts/how-to-read-raw/">‰∏≠Êñá</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#tools-for-reading-raw-data" aria-label="Tools for Reading RAW Data">Tools for Reading RAW Data</a><ul>
                        
                <li>
                    <a href="#dcraw" aria-label="Dcraw">Dcraw</a></li>
                <li>
                    <a href="#rawpylibraw" aria-label="Rawpy/LibRaw">Rawpy/LibRaw</a></li></ul>
                </li>
                <li>
                    <a href="#differences-between-methods-and-brands" aria-label="Differences Between Methods and Brands">Differences Between Methods and Brands</a><ul>
                        
                <li>
                    <a href="#sony" aria-label="Sony">Sony</a><ul>
                        
                <li>
                    <a href="#uncompressed-raw" aria-label="Uncompressed RAW">Uncompressed RAW</a></li>
                <li>
                    <a href="#lossless-compressed-raw" aria-label="Lossless Compressed RAW">Lossless Compressed RAW</a></li>
                <li>
                    <a href="#regarding-dngs-from-capture-one" aria-label="Regarding DNGs from Capture One">Regarding DNGs from Capture One</a></li>
                <li>
                    <a href="#best-practices-for-sony-raw" aria-label="Best Practices for Sony RAW">Best Practices for Sony RAW</a></li></ul>
                </li>
                <li>
                    <a href="#canon" aria-label="Canon">Canon</a></li>
                <li>
                    <a href="#hasselblad" aria-label="Hasselblad">Hasselblad</a></li>
                <li>
                    <a href="#fujifilm" aria-label="Fujifilm">Fujifilm</a></li>
                <li>
                    <a href="#nikon" aria-label="Nikon">Nikon</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="tools-for-reading-raw-data">Tools for Reading RAW Data<a hidden class="anchor" aria-hidden="true" href="#tools-for-reading-raw-data">#</a></h2>
<h3 id="dcraw">Dcraw<a hidden class="anchor" aria-hidden="true" href="#dcraw">#</a></h3>
<p>The most famous tool for reading RAW data is undoubtedly dcraw. Dcraw can convert RAW files of various encoding formats into TIFF or PPM format.</p>
<p>Using the command line <code>dcraw -4 -T -D file_name</code> yields a 16-bit TIFF file that records the direct RAW values, without any processing such as demosaicing, white balancing, or black level subtraction.</p>
<p>Unfortunately, dcraw&rsquo;s last update was on 1 June 2018. Consequently, it no longer includes additional parameters (like white balance, colour matrices, etc.) for cameras released after that date, and even its core function of extracting RAW data may not work reliably.</p>
<p>For instance, with the lossless compressed RAW format introduced by Sony in their fourth-generation cameras (e.g., ILCE-7M4), dcraw reports a &ldquo;cannot decode file&rdquo; error, even though the file extension is still .arw. In contrast, it can still decode the older uncompressed RAW format.</p>
<p><code>dcraw.c</code> is the core file of dcraw, consisting of over ten thousand lines of pure C code.</p>
<h3 id="rawpylibraw">Rawpy/LibRaw<a hidden class="anchor" aria-hidden="true" href="#rawpylibraw">#</a></h3>
<p>Rawpy is a Python wrapper for LibRaw. LibRaw provides a unified interface for accessing RAW data to extract pixel values. It is based on dcraw, having refactored <code>dcraw.c</code> into a more modern and modular library, and has continued to be supported after dcraw ceased development.</p>
<h2 id="differences-between-methods-and-brands">Differences Between Methods and Brands<a hidden class="anchor" aria-hidden="true" href="#differences-between-methods-and-brands">#</a></h2>
<h3 id="sony">Sony<a hidden class="anchor" aria-hidden="true" href="#sony">#</a></h3>
<h4 id="uncompressed-raw">Uncompressed RAW<a hidden class="anchor" aria-hidden="true" href="#uncompressed-raw">#</a></h4>
<p>Test model: ILCE-7CM2:</p>
<p>The following methods yield identical results when reading uncompressed RAW files:</p>
<ul>
<li>Converting with Dcraw to TIFF and then reading with OpenImageIO</li>
<li>Reading directly with Rawpy</li>
<li>Converting with Adobe DNG Converter and then reading with Rawpy</li>
<li>Converting with Adobe Camera Raw and then reading with Rawpy (same as above, although the dimensions appear different when viewed in ACR)</li>
<li>Converting with Adobe DNG Converter, then converting to TIFF with dcraw, and finally reading with OIIO</li>
</ul>
<p>The dimensions read by the above methods are (4688, 7040), which is 33,003,520 pixels, with a value range of 0-16383.</p>
<p>In practice, the DNG files converted by Adobe DNG Converter and Adobe Camera Raw are identical, so this will not be detailed further. Reading DNG files with Rawpy and dcraw is also equivalent.</p>
<p>The following method produces a different result:</p>
<ul>
<li>After converting to DNG with Capture One and then reading with Rawpy (or converting to TIFF with dcraw and then reading), the image becomes (4672, 7008) with a value range of 0-65535. The height is reduced by 16 pixels (8 from the top and 8 from the bottom), and the width is reduced by 32 pixels (12 from the left and 20 from the right). Even after cropping, there are differences compared to the other methods. Looking at the ratio (after normalising both to their respective maximums of 65535 or 16383), the maximum ratio is 1.04, the minimum is 0.95, and the average is 1.00. This alignment was performed by eye in Photoshop.</li>
</ul>
<h4 id="lossless-compressed-raw">Lossless Compressed RAW<a hidden class="anchor" aria-hidden="true" href="#lossless-compressed-raw">#</a></h4>
<p>The principle behind Sony&rsquo;s lossless compressed RAW is to first pad the data with zeros to a multiple of 512, then divide it into blocks, and finally separate it into four sub-images based on the Bayer pattern for differential and Huffman coding.</p>
<p>For lossless compressed RAW, the situation is more complex because there is currently no way to convert between uncompressed ARW and lossless compressed ARW files (if two separate shots are taken, even with tethered shooting, the resulting displacement errors would be larger than one pixel). The following are the tested scenarios:</p>
<ul>
<li>Dcraw does not support lossless compressed RAW (as Sony introduced it after dcraw was no longer being updated).</li>
<li>Reading the ARW with Rawpy yields dimensions of (5120, 7168). This is due to the block-based compression (a multiple of 512). Only the top-left (4688, 7040) area contains image data; the rest is filled with zeros (not the black level), and the values range from 0-16383.</li>
<li>After converting to DNG with Adobe DNG Converter and then reading with Rawpy, the resulting dimensions are (4686, 7038), which is two pixels smaller in each dimension than the uncompressed RAW. If you crop 2 pixels from the bottom and 2 from the right of the padded image from the previous scenario, the results match perfectly, also with a range of 0-16383.</li>
<li>Reading a DNG converted by Capture One with Rawpy also results in dimensions of (4672, 7008) and a range of 0-65535. This is again cropped by 8 pixels top/bottom, and 12 left / 20 right. After cropping the content area of the ARW read by Rawpy, the results are a close match (the average of the differences is even the same, around -5e-6, which requires further testing).</li>
</ul>
<h4 id="regarding-dngs-from-capture-one">Regarding DNGs from Capture One<a hidden class="anchor" aria-hidden="true" href="#regarding-dngs-from-capture-one">#</a></h4>
<p>Theoretically, a codec that decodes RAW and encodes to DNG should not introduce complex errors. However, DNGs exported from Capture One not only have different dimensions but also stretch the original 14-bit data to 16-bit, and they do not perfectly match the RAW data read by other methods.</p>
<p>With the help of Gemini and DeepSeek, a more detailed analysis was conducted. Regarding the conversion from 14-bit to 16-bit, Capture One appears to perform a left bit shift by two places, which is equivalent to multiplying by 4. After left-shifting the ARW data read by Rawpy and then comparing it with the C1-exported DNG (by division and subtraction), the resulting quotient is 1.000004, and the difference is on the order of e-7. The R and B channels match perfectly; all errors come from the two G channels and are content-dependent. In some images, the maximum error in the G channels can reach up to 10%, though in most cases, it does not exceed 5%.</p>
<h4 id="best-practices-for-sony-raw">Best Practices for Sony RAW<a hidden class="anchor" aria-hidden="true" href="#best-practices-for-sony-raw">#</a></h4>
<p>In summary, the recommended approach for using Sony RAW files is to shoot in uncompressed RAW and then read them directly with Rawpy. You can use Adobe DNG Converter to conveniently convert uncompressed RAW files into lossless compressed DNGs to reduce file size without any loss. Alternatively, you can read lossless compressed RAW files with Rawpy and crop them, but be aware that converting lossless compressed RAW to DNG will result in the loss of two rows and two columns of pixels. DNG files obtained through other methods have unknown factors and should not be used.</p>
<h3 id="canon">Canon<a hidden class="anchor" aria-hidden="true" href="#canon">#</a></h3>
<p>Test model: 600D, which outputs CR2 files.</p>
<p>Reading with Rawpy and reading after conversion to DNG yield identical results. The image dimensions are (3516, 5344). The 142 pixels on the left and 51 pixels on the top appear to be the optical black area (the part physically masked for black level calibration), which reads out values close to the black level. The remainder is the image.</p>
<p>Dcraw can process files from the 600D. It reads out the part without the optical black area, which matches the cropped data from Rawpy or a DNG conversion.</p>
<p>The CR3 output from an R6 Mark II (read with Rawpy or via DNG conversion) is similar. The left 154 pixels and top 96 pixels constitute the optical black area, and there is also a white area of 8 pixels on the right.</p>
<h3 id="hasselblad">Hasselblad<a hidden class="anchor" aria-hidden="true" href="#hasselblad">#</a></h3>
<p>Test model: X2D-100C. The camera outputs files in 3FR format.</p>
<p>The sensor in this camera is identifiable; it is highly likely the IMX-461. (Correction: It&rsquo;s not just &ldquo;highly likely&rdquo;; the sensor model IMX-461BQR can be found directly within the 3FR file.)</p>
<p>Hasselblad has several file formats, primarily 3FR and FFF. You can convert from 3FR to FFF using the Phocus software. During conversion, you have options for adjustments and whether to use the embedded 3FR configuration, but these do not affect the resulting FFF file&rsquo;s data when read by other software (e.g., it reads the same with Rawpy). Examining the file headers reveals that 3FR follows the little-endian TIFF specification (starting with <code>49 49 2A 00</code>), while FFF uses the big-endian TIFF specification (starting with <code>4D 4D 00 2A</code>).</p>
<p>The specification sheet for the IMX461-BQR is public. It lists total pixels as 11760x8896, effective pixels as 11664x8750, and active pixels as 11656x8742.</p>
<p>Reading with dcraw or Rawpy produces an image of size 11904x8842, which exceeds the sensor&rsquo;s total pixel count. There is a noisy border around the edge (76px on the left, 68px on the right, 2px on the top, and none on the bottom). Further in is the optical black area (48px on the left and right, 90px on the top, and none on the bottom). The innermost part is an image of size 11664x8750. The width of the image including the black area is 11760 (equal to the total pixel width), but the height is 8840 (which is rather strange).</p>
<p>Both 3FR and FFF files can be converted to DNG. The resulting DNG has the dimensions of the inner image area and can be aligned with it, but the content is slightly different.</p>
<p>Currently, the best method for reading Hasselblad RAW files seems to be reading the 3FR with LibRaw, extracting the image area, and potentially using the optical black area for black level correction.</p>
<h3 id="fujifilm">Fujifilm<a hidden class="anchor" aria-hidden="true" href="#fujifilm">#</a></h3>
<p>Test model: X-T5.</p>
<p>Fujifilm&rsquo;s RAW files are rather unique because their colour filter array is not a standard Bayer pattern but an X-Trans pattern, which has a minimum repeating unit of 6x6 pixels. Fortunately, this does not affect our analysis of the raw image data itself.</p>
<p>Feeding the RAF file directly into Rawpy yields an image with a width of 7872 and a height of 5196. After conversion to DNG, the width is 7728 and the height is 5152. The distribution of the extra 144 pixels in width and 44 pixels in height is as follows:</p>
<ul>
<li>12 pixels of image data on the left; 12 pixels of image data and 120 black pixels on the right.</li>
<li>16 pixels of image data and 5 black pixels at the top; 16 pixels of image data and 7 black pixels at the bottom.</li>
</ul>
<p>The pixel values in the overlapping areas are identical.</p>
<p>Additionally, Rawpy reads the raw pattern from the RAF file incorrectly, whereas the raw pattern in the DNG is correct.</p>
<h3 id="nikon">Nikon<a hidden class="anchor" aria-hidden="true" href="#nikon">#</a></h3>
<p>To be continued</p>
<p>I&rsquo;ve found that the return on investment for this research is extremely low, and there is still much to learn. I will pause after a preliminary investigation of Nikon files. For practical use, the recommendation is to convert files to DNG using Adobe DNG Converter and then read them with Rawpy to directly access the image content.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jackchou.top/en/tags/colour/">Colour</a></li>
      <li><a href="https://jackchou.top/en/tags/isp/">ISP</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://jackchou.top/en/">üè°JacksBlog</a></span> ¬∑ 
        my friends&rsquo; websites: <a href="https://zhxwu.com/">zhxwu.com</a>, <a href="https://ylqian.com/">ylqian.com</a> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><div style="text-align: center; margin-top: 10px; margin-bottom: 20px; width: 100%; display: flex; justify-content: center;">
    <img src="https://visitor-badge.laobi.icu/badge?page_id=jacksblog" alt="visitors" style="max-width: 120px; height: auto;" />
</div>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
