<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Decoding an Adaptive HDR Tone Mapping Algorithm | üè°JacksBlog</title>
<meta name="keywords" content="Colour, HDR, Paper">
<meta name="description" content="Breaking down an innovative tone mapping algorithm and exploring how it balances luminance compression with detail preservation.">
<meta name="author" content="Jack">
<link rel="canonical" href="https://jackchou.top/en/posts/wang-et-al-adaptive-tone-mapping/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.556aa244931a2b8641244b3a88ba5d10d011bee5ef6cc4a8df29bb3ab8574aa9.css" integrity="sha256-VWqiRJMaK4ZBJEs6iLpdENARvuXvbMSo3ym7OrhXSqk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jackchou.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jackchou.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jackchou.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jackchou.top/apple-touch-icon.png">
<link rel="mask-icon" href="https://jackchou.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh-cn" href="https://jackchou.top/posts/wang-et-al-adaptive-tone-mapping/">
<link rel="alternate" hreflang="en" href="https://jackchou.top/en/posts/wang-et-al-adaptive-tone-mapping/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100..900&family=Sen:wght@400..800&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet"><meta property="og:url" content="https://jackchou.top/en/posts/wang-et-al-adaptive-tone-mapping/">
  <meta property="og:site_name" content="üè°JacksBlog">
  <meta property="og:title" content="Decoding an Adaptive HDR Tone Mapping Algorithm">
  <meta property="og:description" content="Breaking down an innovative tone mapping algorithm and exploring how it balances luminance compression with detail preservation.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-23T00:30:00+08:00">
    <meta property="article:modified_time" content="2025-09-23T00:30:00+08:00">
    <meta property="article:tag" content="Colour">
    <meta property="article:tag" content="HDR">
    <meta property="article:tag" content="Paper">
      <meta property="og:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp">
<meta name="twitter:title" content="Decoding an Adaptive HDR Tone Mapping Algorithm">
<meta name="twitter:description" content="Breaking down an innovative tone mapping algorithm and exploring how it balances luminance compression with detail preservation.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts üå≥",
      "item": "https://jackchou.top/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Decoding an Adaptive HDR Tone Mapping Algorithm",
      "item": "https://jackchou.top/en/posts/wang-et-al-adaptive-tone-mapping/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Decoding an Adaptive HDR Tone Mapping Algorithm",
  "name": "Decoding an Adaptive HDR Tone Mapping Algorithm",
  "description": "Breaking down an innovative tone mapping algorithm and exploring how it balances luminance compression with detail preservation.",
  "keywords": [
    "Colour", "HDR", "Paper"
  ],
  "articleBody": "This is my attempt to turn an interesting paper I‚Äôve read into some notes. I will introduce a recently published article and share my findings from trying to replicate it.\nReference: Y. Wang, M. Wei, Z. Ye, T. Hu, and H. Zheng, ‚ÄúAn adaptive tone mapping method for PQ ‚Äê and HLG ‚Äêencoded HDR contents,‚Äù Color Res. Appl., p. col.70002, July 2025, doi: 10.1002/col.70002.\nThis is an adaptive tone mapping algorithm that maps 0-1000 nits HDR content to 0-100 nits SDR. It consists of three parts: tone compression, detail enhancement, and dark area enhancement.\nA Special Kind of Luminance The concept of Luminance in this algorithm is quite special. It is not the Y from the XYZ colour space, but rather the maximum of the RGB values, similar to the Value in HSV.\nThis definition of luminance is used to ensure that values always stay within the RGB space during compression, preventing drastic hue shifts that could be caused by going out of gamut. However, it is worth noting that even if the chromaticity coordinates remain the same, a change in luminance can still alter perceived hue and chroma. An example of this is the Bezold‚ÄìBr√ºcke phenomenon, which describes how our perception of hue can change with light intensity.\nThroughout the paper, ‚Äôluminance‚Äô refers to this specific concept. The RGB space is always linear Rec. 2020. This article does not cover gamut compression; the output is an image in the Rec. 2020 space but with an SDR luminance range.\nThe Tone Compression Curve The tone compression curve is applied to the special luminance mentioned earlier, compressing the range from 0-1000 down to 0-100. This curve is formed by a linear segment and a rational function, creating an overall shape that resembles a roll off. The entire curve lies below the y=x line, which means no part of the image is brightened in this step.\nThe curve is designed around a few specific luminance points, with the function‚Äôs coefficients calculated to connect them smoothly.\nIn Appendix 4.2 of the ITU-R BT.2408 report, it is noted that skin tones on an HLG display with a peak luminance of 1000 nits should correspond to 45% to 56% of the HLG signal (with an average of 50%). On an SDR display with a peak luminance of 100 nits, they should correspond to 61% to 82% of the SDR signal (with an average of 70%). Therefore, the luminance of skin tones is approximately 50.7 nits in HDR content and 42.5 nits in SDR content. This 50.7 nits value is also used as the knee point between the linear segment and the curve.\nAnother pair of luminance points is for diffuse white. In a 1000-nit HDR system, the recommended luminance for diffuse white is 203 nits. In an SDR system, it is typically set to a 92% signal value, which is about 81.7 nits.\nDetail Decomposition and Enhancement Compressing luminance leads to a loss of detail, especially in the highlights where textures become hard to distinguish due to reduced contrast. Before compressing the luminance, a bilateral filter is used to separate the base layer from the detail layer. Tone compression is applied only to the base layer. The detail layer, on the other hand, undergoes an additional enhancement process to suppress potential halos around high contrast edges in the image.\nThe paper provides a set of recommended empirical values for the three main parameters of the bilateral filter: window size, spatial variance, and range variance.\nThe additional detail enhancement is based on the local variance of the area surrounding a pixel and the global variance of the entire image. However, the relevant formulae in the paper are almost all incorrect and the textual descriptions are brief, so I have not yet been able to fully replicate this part.\n$$ \\sigma_G = \\sqrt{\\frac{\\sum_{p \\in I} \\left( L_{\\mathrm{HDR}}(p) - \\overline{L}_{\\mathrm{HDR},I} \\right)}{N}} $$$$ \\sigma_L(p) = \\sqrt{\\frac{\\sum_{q_i \\in \\Omega_i} \\left( L_{\\mathrm{HDR}}(q_i) - \\overline{L}_{\\mathrm{HDR},\\Omega_i} \\right)}{N_i}} $$The two formulae above are from the paper, but their results are always 0. If you add squares to make them variance or standard deviation calculations, the subsequent steps still do not work correctly.\nBroadly speaking, the idea is to first calculate the variance (or possibly standard deviation) of all pixels in the entire image. Then, for each pixel, you calculate the variance or standard deviation of the surrounding neighbourhood. A threshold is set based on the global variance, and only the details corresponding to areas exceeding this threshold are enhanced.\nDark Region Enhancement After the first two steps, we have an image suitable for an SDR display. Most images do not need this final step. In my tests, the dark area enhancement is only triggered when the average luminance of the input image is below about 1 nit. The clustering I implemented with SciPy is very slow, but the brightening effect from this step is quite good.\nSince the tone compression curve is always below the y=x line, it reduces the image‚Äôs overall luminance. If the original content is already quite dark, the output image might become too dim, a problem exacerbated by the poor performance of SDR transfer functions in dark regions. The authors therefore designed an optional module to enhance dark areas. This module is activated only if the average luminance of the mapped image is below a certain threshold; otherwise, the image is output directly.\nFirst, all pixels in the image are grouped into 64 clusters based on their luminance. The average luminance of each cluster is calculated and stored in a 64 element vector. Two gamma values are set, for instance, 1 (for the brightest cluster) and 2.2 (for the darkest cluster). The other 62 gamma values are derived through linear interpolation, with the intervals determined by the average luminance of the clusters.\nThen, the reciprocal of these gamma values is applied to the luminance of the pixels in each respective cluster, brightening the image. This acts as a dynamically adaptive system gamma.\nResults I tested the algorithm using a post processed photo. During editing, I controlled the luminance of different elements in the image to adhere as closely as possible to HDR production standards.\nIf we simply clip any values above the nominal SDR luminance, parts of the image become pure white.\nWith the partially replicated detail enhancement turned off, which means only applying the tone compression curve, the highlights in the image are recovered quite well.\nBy modifying the detail enhancement formula to calculate standard deviation and using a manually specified threshold, I got a more complete result. You can see some processing along the high contrast edges.\nAlthough I couldn‚Äôt fully replicate the detail enhancement, the tone compression curve applied to the special luminance already produces good results and is very fast. In contrast, the bilateral filter and local variance calculations needed for detail enhancement are computationally expensive.\nIt must be pointed out, however, that the core of this algorithm is the tone compression curve, which is designed based on HDR and SDR production standards and experience. If the HDR content was not created according to these standards and has a more ‚Äúfreestyle‚Äù luminance distribution, the results may not be as effective.\nOnce all the details and potential errors in the algorithm are confirmed, I will refine the article. It would be ideal if the code could be made open source.\n",
  "wordCount" : "1223",
  "inLanguage": "en",
  "image": "https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp","datePublished": "2025-09-23T00:30:00+08:00",
  "dateModified": "2025-09-23T00:30:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Jack"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jackchou.top/en/posts/wang-et-al-adaptive-tone-mapping/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "üè°JacksBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jackchou.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jackchou.top/en/" accesskey="h" title="üè°JacksBlog (Alt + H)">üè°JacksBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://jackchou.top/" title="‰∏≠Êñá"
                            aria-label="‰∏≠Êñá">‰∏≠Êñá</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jackchou.top/en/posts/" title="Posts üå≥">
                    <span>Posts üå≥</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/photos/" title="Photos üì∑">
                    <span>Photos üì∑</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/tags/" title="Tags üè∑Ô∏è">
                    <span>Tags üè∑Ô∏è</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/en/about/" title="About üòº">
                    <span>About üòº</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Decoding an Adaptive HDR Tone Mapping Algorithm
    </h1>
    <div class="post-meta"><span title='2025-09-23 00:30:00 +0800 +0800'>2025.09.23</span>&nbsp;¬∑&nbsp;Jack&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="https://jackchou.top/posts/wang-et-al-adaptive-tone-mapping/">‰∏≠Êñá</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#a-special-kind-of-luminance" aria-label="A Special Kind of Luminance">A Special Kind of Luminance</a></li>
                <li>
                    <a href="#the-tone-compression-curve" aria-label="The Tone Compression Curve">The Tone Compression Curve</a></li>
                <li>
                    <a href="#detail-decomposition-and-enhancement" aria-label="Detail Decomposition and Enhancement">Detail Decomposition and Enhancement</a></li>
                <li>
                    <a href="#dark-region-enhancement" aria-label="Dark Region Enhancement">Dark Region Enhancement</a></li>
                <li>
                    <a href="#results" aria-label="Results">Results</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>This is my attempt to turn an interesting paper I&rsquo;ve read into some notes. I will introduce a recently published article and share my findings from trying to replicate it.</p>
<p>Reference: Y. Wang, M. Wei, Z. Ye, T. Hu, and H. Zheng, ‚ÄúAn adaptive tone mapping method for PQ ‚Äê and HLG ‚Äêencoded HDR contents,‚Äù <em>Color Res. Appl.</em>, p. col.70002, July 2025, doi: <a href="https://doi.org/10.1002/col.70002">10.1002/col.70002</a>.</p>
<p>This is an adaptive tone mapping algorithm that maps 0-1000 nits HDR content to 0-100 nits SDR. It consists of three parts: tone compression, detail enhancement, and dark area enhancement.</p>
<h2 id="a-special-kind-of-luminance">A Special Kind of Luminance<a hidden class="anchor" aria-hidden="true" href="#a-special-kind-of-luminance">#</a></h2>
<p>The concept of Luminance in this algorithm is quite special. It is not the Y from the XYZ colour space, but rather the maximum of the RGB values, similar to the Value in HSV.</p>
<p>This definition of luminance is used to ensure that values always stay within the RGB space during compression, preventing drastic hue shifts that could be caused by going out of gamut. However, it is worth noting that even if the chromaticity coordinates remain the same, a change in luminance can still alter perceived hue and chroma. An example of this is the Bezold‚ÄìBr√ºcke phenomenon, which describes how our perception of hue can change with light intensity.</p>
<p>Throughout the paper, &rsquo;luminance&rsquo; refers to this specific concept. The RGB space is always linear Rec. 2020. This article does not cover gamut compression; the output is an image in the Rec. 2020 space but with an SDR luminance range.</p>
<h2 id="the-tone-compression-curve">The Tone Compression Curve<a hidden class="anchor" aria-hidden="true" href="#the-tone-compression-curve">#</a></h2>
<p>The tone compression curve is applied to the special luminance mentioned earlier, compressing the range from 0-1000 down to 0-100. This curve is formed by a linear segment and a rational function, creating an overall shape that resembles a roll off. The entire curve lies below the y=x line, which means no part of the image is brightened in this step.</p>
<p>The curve is designed around a few specific luminance points, with the function&rsquo;s coefficients calculated to connect them smoothly.</p>
<p>In Appendix 4.2 of the ITU-R BT.2408 report, it is noted that skin tones on an HLG display with a peak luminance of 1000 nits should correspond to 45% to 56% of the HLG signal (with an average of 50%). On an SDR display with a peak luminance of 100 nits, they should correspond to 61% to 82% of the SDR signal (with an average of 70%). Therefore, the luminance of skin tones is approximately 50.7 nits in HDR content and 42.5 nits in SDR content. This 50.7 nits value is also used as the knee point between the linear segment and the curve.</p>
<p>Another pair of luminance points is for diffuse white. In a 1000-nit HDR system, the recommended luminance for diffuse white is 203 nits. In an SDR system, it is typically set to a 92% signal value, which is about 81.7 nits.</p>
<p><img alt="Tone Curve" loading="lazy" src="https://img.jackchou.top/jack-img/2025/09/2bdaba5a48292b81c91cd7569d698e1a.svg"></p>
<h2 id="detail-decomposition-and-enhancement">Detail Decomposition and Enhancement<a hidden class="anchor" aria-hidden="true" href="#detail-decomposition-and-enhancement">#</a></h2>
<p>Compressing luminance leads to a loss of detail, especially in the highlights where textures become hard to distinguish due to reduced contrast. Before compressing the luminance, a bilateral filter is used to separate the base layer from the detail layer. Tone compression is applied only to the base layer. The detail layer, on the other hand, undergoes an additional enhancement process to suppress potential halos around high contrast edges in the image.</p>
<p>The paper provides a set of recommended empirical values for the three main parameters of the bilateral filter: window size, spatial variance, and range variance.</p>
<p>The additional detail enhancement is based on the local variance of the area surrounding a pixel and the global variance of the entire image. However, the relevant formulae in the paper are almost all incorrect and the textual descriptions are brief, so I have not yet been able to fully replicate this part.</p>
$$
\sigma_G = \sqrt{\frac{\sum_{p \in I} \left( L_{\mathrm{HDR}}(p) - \overline{L}_{\mathrm{HDR},I} \right)}{N}}
$$$$
\sigma_L(p) = \sqrt{\frac{\sum_{q_i \in \Omega_i} \left( L_{\mathrm{HDR}}(q_i) - \overline{L}_{\mathrm{HDR},\Omega_i} \right)}{N_i}}
$$<p>The two formulae above are from the paper, but their results are always 0. If you add squares to make them variance or standard deviation calculations, the subsequent steps still do not work correctly.</p>
<p>Broadly speaking, the idea is to first calculate the variance (or possibly standard deviation) of all pixels in the entire image. Then, for each pixel, you calculate the variance or standard deviation of the surrounding neighbourhood. A threshold is set based on the global variance, and only the details corresponding to areas exceeding this threshold are enhanced.</p>
<h2 id="dark-region-enhancement">Dark Region Enhancement<a hidden class="anchor" aria-hidden="true" href="#dark-region-enhancement">#</a></h2>
<p>After the first two steps, we have an image suitable for an SDR display. Most images do not need this final step. In my tests, the dark area enhancement is only triggered when the average luminance of the input image is below about 1 nit. The clustering I implemented with SciPy is very slow, but the brightening effect from this step is quite good.</p>
<p>Since the tone compression curve is always below the y=x line, it reduces the image&rsquo;s overall luminance. If the original content is already quite dark, the output image might become too dim, a problem exacerbated by the poor performance of SDR transfer functions in dark regions. The authors therefore designed an optional module to enhance dark areas. This module is activated only if the average luminance of the mapped image is below a certain threshold; otherwise, the image is output directly.</p>
<p>First, all pixels in the image are grouped into 64 clusters based on their luminance. The average luminance of each cluster is calculated and stored in a 64 element vector. Two gamma values are set, for instance, 1 (for the brightest cluster) and 2.2 (for the darkest cluster). The other 62 gamma values are derived through linear interpolation, with the intervals determined by the average luminance of the clusters.</p>
<p>Then, the reciprocal of these gamma values is applied to the luminance of the pixels in each respective cluster, brightening the image. This acts as a dynamically adaptive system gamma.</p>
<h2 id="results">Results<a hidden class="anchor" aria-hidden="true" href="#results">#</a></h2>
<p>I tested the algorithm using a post processed photo. During editing, I controlled the luminance of different elements in the image to adhere as closely as possible to HDR production standards.</p>
<p><img alt="Input HDR image" loading="lazy" src="https://img.jackchou.top/jack-img/2025/09/fb7414333933aa0f9f4f42a64dc08eae.avif"></p>
<p>If we simply clip any values above the nominal SDR luminance, parts of the image become pure white.</p>
<p><img alt="Result of clipping only" loading="lazy" src="https://img.jackchou.top/jack-img/2025/09/0d59aba54c76a7e4684bc2f16acf29e2.avif"></p>
<p>With the partially replicated detail enhancement turned off, which means only applying the tone compression curve, the highlights in the image are recovered quite well.</p>
<p><img alt="Result without detail enhancement" loading="lazy" src="https://img.jackchou.top/jack-img/2025/09/3e99b030d42a9877fb07b236ddf64390.avif"></p>
<p>By modifying the detail enhancement formula to calculate standard deviation and using a manually specified threshold, I got a more complete result. You can see some processing along the high contrast edges.</p>
<p><img alt="Full replication, including possibly incorrect detail enhancement" loading="lazy" src="https://img.jackchou.top/jack-img/2025/09/9ec468ccc3bf4eafdf177e0f8d9ebe9a.avif"></p>
<p>Although I couldn&rsquo;t fully replicate the detail enhancement, the tone compression curve applied to the special luminance already produces good results and is very fast. In contrast, the bilateral filter and local variance calculations needed for detail enhancement are computationally expensive.</p>
<p>It must be pointed out, however, that the core of this algorithm is the tone compression curve, which is designed based on HDR and SDR production standards and experience. If the HDR content was not created according to these standards and has a more &ldquo;freestyle&rdquo; luminance distribution, the results may not be as effective.</p>
<p>Once all the details and potential errors in the algorithm are confirmed, I will refine the article. It would be ideal if the code could be made open source.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jackchou.top/en/tags/colour/">Colour</a></li>
      <li><a href="https://jackchou.top/en/tags/hdr/">HDR</a></li>
      <li><a href="https://jackchou.top/en/tags/paper/">Paper</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://jackchou.top/en/">üè°JacksBlog</a></span> ¬∑ 
        my friends&rsquo; websites: <a href="https://zhxwu.com/">zhxwu.com</a>, <a href="https://ylqian.com/">ylqian.com</a> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><div style="text-align: center; margin-top: 10px; margin-bottom: 20px; width: 100%; display: flex; justify-content: center;">
    <img src="https://visitor-badge.laobi.icu/badge?page_id=jacksblog" alt="visitors" style="max-width: 120px; height: auto;" />
</div>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
