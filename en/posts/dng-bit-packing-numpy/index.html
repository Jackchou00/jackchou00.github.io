<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bit Packing in DNG Images and Its Implementation | JacksBlog</title>
<meta name=keywords content="DNG,Bit Packing,PiDNG,numpy2dng"><meta name=description content="Efficiently pack 10/12/14-bit RAW data for DNG using Numpy. Learn to handle padding for odd widths and discover numpy2dng, a bug-fixed alternative to PiDNG."><meta name=author content="Miaosen Zhou"><link rel=canonical href=https://jackchou.top/en/posts/dng-bit-packing-numpy/><link crossorigin=anonymous href=/assets/css/stylesheet.2ff386b10b02a361d472eab220247dbdf4bb7faecac9567e482555e7ba4cc9ba.css integrity="sha256-L/OGsQsCo2HUcuqyICR9vfS7f67KyVZ+SCVV57pMybo=" rel="preload stylesheet" as=style><link rel=icon href=https://jackchou.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jackchou.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jackchou.top/favicon-32x32.png><link rel=apple-touch-icon href=https://jackchou.top/apple-touch-icon.png><link rel=mask-icon href=https://jackchou.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://jackchou.top/posts/dng-bit-packing-numpy/><link rel=alternate hreflang=en href=https://jackchou.top/en/posts/dng-bit-packing-numpy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://cdn.jsdelivr.net><meta property="og:url" content="https://jackchou.top/en/posts/dng-bit-packing-numpy/"><meta property="og:site_name" content="JacksBlog"><meta property="og:title" content="Bit Packing in DNG Images and Its Implementation"><meta property="og:description" content="Efficiently pack 10/12/14-bit RAW data for DNG using Numpy. Learn to handle padding for odd widths and discover numpy2dng, a bug-fixed alternative to PiDNG."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-03T00:33:13+08:00"><meta property="article:modified_time" content="2026-01-03T02:16:29+08:00"><meta property="article:tag" content="Code"><meta property="article:tag" content="RAW"><meta property="article:tag" content="Camera"><meta property="og:image" content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp"><meta name=twitter:title content="Bit Packing in DNG Images and Its Implementation"><meta name=twitter:description content="Efficiently pack 10/12/14-bit RAW data for DNG using Numpy. Learn to handle padding for odd widths and discover numpy2dng, a bug-fixed alternative to PiDNG."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts üå≥","item":"https://jackchou.top/en/posts/"},{"@type":"ListItem","position":2,"name":"Bit Packing in DNG Images and Its Implementation","item":"https://jackchou.top/en/posts/dng-bit-packing-numpy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bit Packing in DNG Images and Its Implementation","name":"Bit Packing in DNG Images and Its Implementation","description":"Efficiently pack 10/12/14-bit RAW data for DNG using Numpy. Learn to handle padding for odd widths and discover numpy2dng, a bug-fixed alternative to PiDNG.","keywords":["DNG","Bit Packing","PiDNG","numpy2dng"],"articleBody":"Bit Packing Camera ADCs typically output 10, 12, or 14-bit data, which exceeds a single byte. The simplest way to store such data is using 16-bit integers (uint16). However, this wastes some space: 10-bit data wastes 6 bits, 12-bit data wastes 4 bits, and 14-bit data wastes 2 bits.\nEven without any advanced compression, bit packing alone can save considerable space. The principle of bit packing is to arrange data from multiple pixels tightly together, avoiding the wasted space of higher bit-depth containers. For example, four 10-bit pixels can be packed into 5 bytes (40 bits), whereas storing them as 16-bit integers would require 8 bytes (64 bits), saving 37.5% of space.\n12-bit and 14-bit data can be packed similarly:\nTwo 12-bit pixels can be packed into 3 bytes (24 bits), saving 25% of space. Four 14-bit pixels can be packed into 7 bytes (56 bits), saving 12.5% of space. DNG is an extension of the TIFF format, and its specification requires bit packing to store pixel data other than 8-bit and 16-bit to save space.\nBit Packing with Numpy The PiDNG library provides functionality to convert Numpy arrays to DNG format, which involves bit packing.\nThe 14-bit packing code in PiDNG contains an error, attempting to pack 6 14-bit pixels into 7 bytes. I have used this code to test the coding capabilities of LLMs. Additionally, the bit operations used for 12-bit packing have a subtle flaw that no model has yet identified. For details, see Using LLMs for Colour Science: Best Practices and Test.\nTaking the simplest 12-bit packing as an example, here is how to implement bit packing using Numpy.\ndef pack12(data: np.ndarray) -\u003e np.ndarray: out = np.zeros((data.shape[0], int(data.shape[1] * 3 // 2)), dtype=np.uint8) out[:, ::3] = (data[:, ::2] \u0026 0x0FF0) \u003e\u003e 4 out[:, 1::3] = (data[:, ::2] \u0026 0x000F) \u003c\u003c 4 | (data[:, 1::2] \u0026 0x0F00) \u003e\u003e 8 out[:, 2::3] = data[:, 1::2] \u0026 0x00FF return out This function takes a two-dimensional Numpy array data representing pixel values of an image, where each pixel is a 16-bit unsigned integer in the range 0 to 4095 (12 bits), meaning only the lower 12 bits are used.\nFirst, a new array out is created with a width 1.5 times that of the original array (since every 2 pixels are packed into 3 bytes), with uint8 data type corresponding to one byte.\nThen, using bitwise operations and Numpy slicing, the data from every two 12-bit pixels is split and stored in the out array:\nThe first byte stores the upper 8 bits of the first pixel, obtained using an AND operation and right-shifting by 4 bits. The upper 4 bits of the second byte store the lower 4 bits of the first pixel, whilst the lower 4 bits store the upper 4 bits of the second pixel, achieved through AND operations and bit shifting. The third byte stores the lower 8 bits of the second pixel, obtained using an AND operation. These bitwise and slicing operations are vectorised, allowing efficient processing of the entire array.\nPadding The code above looks quite elegant, but it assumes that the input image width is even. For odd-width images, the created out array would have an incorrect size, causing the slicing operations to fail. Similarly, 10-bit and 14-bit images require widths that are multiples of 4.\nReviewing the principles of bit packing, the following requirements must be met:\nContinuous bit stream: All pixel data in a row is treated as a continuous bit stream. For example, in a 10-bit image, pixel 1 occupies bits 0-9, pixel 2 occupies bits 10-19, and so on. Byte alignment: The minimum unit for file storage is a byte (8 bits). End-of-row padding: When the total number of bits in a row is not divisible by 8, zeros are padded at the end of the row until the next byte is filled. To solve this problem whilst maintaining the efficiency of bitwise operations, padding is introduced when the input image width is odd. Specifically, extra columns are added to the right side of the input array, filled with zeros. After packing, the excess bytes are removed.\nFor a 10-bit image with width 101, the padding and packing process is as follows:\nThe 10-bit packing method packs every 4 pixels into 5 bytes, so the width needs to be padded to the nearest multiple of 4, which is 104. Pad with 3 columns of zeros, making the input array width 104. Perform bit packing, packing each row into 104 / 4 * 5 = 130 bytes. Calculate the actual number of bytes needed: 101 pixels occupy 1010 bits, which is 126.25 bytes, rounded up to 127 bytes. Finally, extract the first 127 bytes from the packed array, discarding the excess 3 bytes. This approach satisfies the requirements of bit packing, enables packing of images with arbitrary widths, and maintains efficiency in practice.\nImprovements on PiDNG: numpy2dng The bit packing in the PiDNG library does not account for padding and can only correctly handle images with widths that are multiples of 4 (10-bit), multiples of 2 (12-bit), and multiples of 4 (14-bit). For images with other widths, errors occur during slicing.\nBesides bit packing, PiDNG also supports lossless compression using JPEG92, implemented in C via ljpeg92. Although more efficient, this requires on-site compilation during installation. In complex environments, this may lead to installation failures:\nResolved 15 packages in 15ms √ó Failed to build `pidng==4.0.9` ‚îú‚îÄ‚ñ∂ The build backend returned an error ‚ï∞‚îÄ‚ñ∂ Call to `setuptools.build_meta:__legacy__.build_wheel` failed (exit code: 1) There are also some minor issues, such as Raspberry Pi-specific camera metadata in the code, a rather large RAW sample file in the Git repository, and the error in 14-bit packing.\nTherefore, with the collaboration of MiMo-V2-Flash and GPT-5.2, building upon PiDNG, we temporarily removed JPEG92 compression, fixed the bit packing issues, switched to the more modern uv and hatchling for packaging, removed unnecessary files, and released a new library called numpy2dng. It can be installed directly via pip or uv:\npip install numpy2dng # or uv add numpy2dng The interface remains largely consistent with PiDNG, making it convenient to save Numpy arrays as DNG files.\n","wordCount":"1025","inLanguage":"en","image":"https://img.jackchou.top/jack-img/2025/08/81bb602c03f9704ee42e292468396187.webp","datePublished":"2026-01-03T00:33:13+08:00","dateModified":"2026-01-03T02:16:29+08:00","author":{"@type":"Person","name":"Miaosen Zhou"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jackchou.top/en/posts/dng-bit-packing-numpy/"},"publisher":{"@type":"Organization","name":"JacksBlog","logo":{"@type":"ImageObject","url":"https://jackchou.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jackchou.top/en/ accesskey=h title="JacksBlog (Alt + H)">JacksBlog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://jackchou.top/ title=‰∏≠Êñá aria-label=‰∏≠Êñá>‰∏≠Êñá</a></li></ul></div></div><ul id=menu><li><a href=https://jackchou.top/en/posts/ title="Posts üå≥"><span>Posts üå≥</span></a></li><li><a href=https://jackchou.top/en/photos/ title="Photos üì∑"><span>Photos üì∑</span></a></li><li><a href=https://jackchou.top/en/tags/ title="Tags üè∑Ô∏è"><span>Tags üè∑Ô∏è</span></a></li><li><a href=https://jackchou.top/en/about/ title="About üòº"><span>About üòº</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Bit Packing in DNG Images and Its Implementation</h1><div class=post-meta><span title='2026-01-03 00:33:13 +0800 +0800'>2026.01.03</span>&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://jackchou.top/posts/dng-bit-packing-numpy/>‰∏≠Êñá</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#bit-packing aria-label="Bit Packing">Bit Packing</a></li><li><a href=#bit-packing-with-numpy aria-label="Bit Packing with Numpy">Bit Packing with Numpy</a></li><li><a href=#padding aria-label=Padding>Padding</a></li><li><a href=#improvements-on-pidng-numpy2dng aria-label="Improvements on PiDNG: numpy2dng">Improvements on PiDNG: numpy2dng</a></li></ul></div></details></div><div class=post-content><h2 id=bit-packing>Bit Packing<a hidden class=anchor aria-hidden=true href=#bit-packing>#</a></h2><p>Camera ADCs typically output 10, 12, or 14-bit data, which exceeds a single byte. The simplest way to store such data is using 16-bit integers (uint16). However, this wastes some space: 10-bit data wastes 6 bits, 12-bit data wastes 4 bits, and 14-bit data wastes 2 bits.</p><p>Even without any advanced compression, bit packing alone can save considerable space. The principle of bit packing is to arrange data from multiple pixels tightly together, avoiding the wasted space of higher bit-depth containers. For example, four 10-bit pixels can be packed into 5 bytes (40 bits), whereas storing them as 16-bit integers would require 8 bytes (64 bits), saving 37.5% of space.</p><p>12-bit and 14-bit data can be packed similarly:</p><ul><li>Two 12-bit pixels can be packed into 3 bytes (24 bits), saving 25% of space.</li><li>Four 14-bit pixels can be packed into 7 bytes (56 bits), saving 12.5% of space.</li></ul><p>DNG is an extension of the TIFF format, and its specification requires bit packing to store pixel data other than 8-bit and 16-bit to save space.</p><h2 id=bit-packing-with-numpy>Bit Packing with Numpy<a hidden class=anchor aria-hidden=true href=#bit-packing-with-numpy>#</a></h2><p>The PiDNG library provides functionality to convert Numpy arrays to DNG format, which involves bit packing.</p><p><em>The 14-bit packing code in PiDNG contains an error, attempting to pack 6 14-bit pixels into 7 bytes. I have used this code to test the coding capabilities of LLMs. Additionally, the bit operations used for 12-bit packing have a subtle flaw that no model has yet identified. For details, see <a href=/en/posts/llm-for-colour/>Using LLMs for Colour Science: Best Practices and Test</a>.</em></p><p>Taking the simplest 12-bit packing as an example, here is how to implement bit packing using Numpy.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pack12</span>(data: np<span style=color:#f92672>.</span>ndarray) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>    out <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((data<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>], int(data<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>)), dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint8)
</span></span><span style=display:flex><span>    out[:, ::<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> (data[:, ::<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0FF0</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>    out[:, <span style=color:#ae81ff>1</span>::<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> (data[:, ::<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x000F</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>|</span> (data[:, <span style=color:#ae81ff>1</span>::<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0F00</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>    out[:, <span style=color:#ae81ff>2</span>::<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> data[:, <span style=color:#ae81ff>1</span>::<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x00FF</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> out
</span></span></code></pre></div><p>This function takes a two-dimensional Numpy array <code>data</code> representing pixel values of an image, where each pixel is a 16-bit unsigned integer in the range 0 to 4095 (12 bits), meaning only the lower 12 bits are used.</p><p>First, a new array <code>out</code> is created with a width 1.5 times that of the original array (since every 2 pixels are packed into 3 bytes), with <code>uint8</code> data type corresponding to one byte.</p><p>Then, using bitwise operations and Numpy slicing, the data from every two 12-bit pixels is split and stored in the <code>out</code> array:</p><ul><li>The first byte stores the upper 8 bits of the first pixel, obtained using an AND operation and right-shifting by 4 bits.</li><li>The upper 4 bits of the second byte store the lower 4 bits of the first pixel, whilst the lower 4 bits store the upper 4 bits of the second pixel, achieved through AND operations and bit shifting.</li><li>The third byte stores the lower 8 bits of the second pixel, obtained using an AND operation.</li></ul><p>These bitwise and slicing operations are vectorised, allowing efficient processing of the entire array.</p><h2 id=padding>Padding<a hidden class=anchor aria-hidden=true href=#padding>#</a></h2><p>The code above looks quite elegant, but it assumes that the input image width is even. For odd-width images, the created <code>out</code> array would have an incorrect size, causing the slicing operations to fail. Similarly, 10-bit and 14-bit images require widths that are multiples of 4.</p><p>Reviewing the principles of bit packing, the following requirements must be met:</p><ul><li>Continuous bit stream: All pixel data in a row is treated as a continuous bit stream. For example, in a 10-bit image, pixel 1 occupies bits 0-9, pixel 2 occupies bits 10-19, and so on.</li><li>Byte alignment: The minimum unit for file storage is a byte (8 bits).</li><li>End-of-row padding: When the total number of bits in a row is not divisible by 8, zeros are padded at the end of the row until the next byte is filled.</li></ul><p>To solve this problem whilst maintaining the efficiency of bitwise operations, padding is introduced when the input image width is odd. Specifically, extra columns are added to the right side of the input array, filled with zeros. After packing, the excess bytes are removed.</p><p>For a 10-bit image with width 101, the padding and packing process is as follows:</p><ol><li>The 10-bit packing method packs every 4 pixels into 5 bytes, so the width needs to be padded to the nearest multiple of 4, which is 104.</li><li>Pad with 3 columns of zeros, making the input array width 104.</li><li>Perform bit packing, packing each row into 104 / 4 * 5 = 130 bytes.</li><li>Calculate the actual number of bytes needed: 101 pixels occupy 1010 bits, which is 126.25 bytes, rounded up to 127 bytes.</li><li>Finally, extract the first 127 bytes from the packed array, discarding the excess 3 bytes.</li></ol><p>This approach satisfies the requirements of bit packing, enables packing of images with arbitrary widths, and maintains efficiency in practice.</p><h2 id=improvements-on-pidng-numpy2dng>Improvements on PiDNG: numpy2dng<a hidden class=anchor aria-hidden=true href=#improvements-on-pidng-numpy2dng>#</a></h2><p>The bit packing in the PiDNG library does not account for padding and can only correctly handle images with widths that are multiples of 4 (10-bit), multiples of 2 (12-bit), and multiples of 4 (14-bit). For images with other widths, errors occur during slicing.</p><p>Besides bit packing, PiDNG also supports lossless compression using JPEG92, implemented in C via <code>ljpeg92</code>. Although more efficient, this requires on-site compilation during installation. In complex environments, this may lead to installation failures:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Resolved <span style=color:#ae81ff>15</span> packages in 15ms
</span></span><span style=display:flex><span>  √ó Failed to build <span style=color:#e6db74>`</span>pidng<span style=color:#f92672>==</span>4.0.9<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>  ‚îú‚îÄ‚ñ∂ The build backend returned an error
</span></span><span style=display:flex><span>  ‚ï∞‚îÄ‚ñ∂ Call to <span style=color:#e6db74>`</span>setuptools.build_meta:__legacy__.build_wheel<span style=color:#e6db74>`</span> failed <span style=color:#f92672>(</span>exit code: 1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>There are also some minor issues, such as Raspberry Pi-specific camera metadata in the code, a rather large RAW sample file in the Git repository, and the error in 14-bit packing.</p><p>Therefore, with the collaboration of <code>MiMo-V2-Flash</code> and <code>GPT-5.2</code>, building upon PiDNG, we temporarily removed JPEG92 compression, fixed the bit packing issues, switched to the more modern <code>uv</code> and <code>hatchling</code> for packaging, removed unnecessary files, and released a new library called <code>numpy2dng</code>. It can be installed directly via pip or uv:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install numpy2dng
</span></span><span style=display:flex><span><span style=color:#75715e># or</span>
</span></span><span style=display:flex><span>uv add numpy2dng
</span></span></code></pre></div><p>The interface remains largely consistent with PiDNG, making it convenient to save Numpy arrays as DNG files.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jackchou.top/en/tags/code/>Code</a></li><li><a href=https://jackchou.top/en/tags/raw/>RAW</a></li><li><a href=https://jackchou.top/en/tags/camera/>Camera</a></li></ul><nav class=paginav><a class=next href=https://jackchou.top/en/posts/iso-gainmap-alternate-headroom/><span class=title>Next ¬ª</span><br><span>HDR Image Formats (V): Understanding Headroom in Gainmap</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://jackchou.top/en/>JacksBlog</a></span> ¬∑
my friends&rsquo; websites: <a href=https://zhxwu.com/>zhxwu.com</a>, <a href=https://ylqian.com/>ylqian.com</a> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/js/site.min.a576538c52b362e170acc02d53f5ce6045117863354954a8f91f10c7217d94ab.js integrity="sha256-pXZTjFKzYuFwrMAtU/XOYEUReGM1SVSo+R8QxyF9lKs="></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>