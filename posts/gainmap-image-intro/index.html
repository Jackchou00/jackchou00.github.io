<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>HDR 图像格式解析（一）：Gainmap 的基本概念 | 🏡JacksBlog</title>
<meta name="keywords" content="Colour, HDR, Gainmap">
<meta name="description" content="这是 HDR 静态图像格式解析系列的第一篇，旨在介绍一种新的图像格式：Gainmap 的基本概念，通过增加一层增益图和元数据的方式，实现 HDR 静态图像的存储。其特点在于，是一种与 SDR 兼容性很好，相对亮度的 HDR 格式。">
<meta name="author" content="">
<link rel="canonical" href="https://jackchou.top/posts/gainmap-image-intro/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bb4e9ae2e440bccf3cb7d24276f41ff835376bf2c78193c51417a098608382c4.css" integrity="sha256-u06a4uRAvM88t9JCdvQf&#43;DU3a/LHgZPFFBegmGCDgsQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jackchou.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jackchou.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jackchou.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jackchou.top/apple-touch-icon.png">
<link rel="mask-icon" href="https://jackchou.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh-cn" href="https://jackchou.top/posts/gainmap-image-intro/">
<link rel="alternate" hreflang="en" href="https://jackchou.top/en/posts/gainmap-image-intro/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&family=Noto+Sans+SC:wght@100..900&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">


<style>
#domain-migration-notice {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 12px 20px;
  text-align: center;
  z-index: 1000;
  font-size: 14px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  display: none;
}

#domain-migration-notice.show {
  display: block;
}

#domain-migration-notice .notice-content {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
}

#domain-migration-notice .notice-text {
  flex: 1;
  text-align: center;
}

#domain-migration-notice .close-btn {
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.3);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.3s;
}

#domain-migration-notice .close-btn:hover {
  background: rgba(255,255,255,0.3);
}

#domain-migration-notice a {
  color: #ffeb3b;
  text-decoration: underline;
}

body.notice-shown {
  padding-top: 60px;
}

@media (max-width: 768px) {
  #domain-migration-notice {
    padding: 10px 15px;
    font-size: 13px;
  }
  
  #domain-migration-notice .notice-content {
    flex-direction: column;
    gap: 8px;
  }
  
  body.notice-shown {
    padding-top: 80px;
  }
}
</style>

<script>
(function() {
  
  const expiryDate = new Date('2025-10-31');
  const now = new Date();
  
  if (now > expiryDate) {
    return; 
  }
  
  
  if (localStorage.getItem('domain-migration-dismissed') === 'true') {
    return;
  }
  
  
  const noticeHTML = `
    <div id="domain-migration-notice">
      <div class="notice-content">
        <div class="notice-text">
          <span class="zh-notice" style="display: none;">
            👋 再见，jackchou00.icu    🚀 新的旅途，从 <a href="https://jackchou.top">jackchou.top</a> 起程
          </span>
          <span class="en-notice" style="display: none;">
            👋 Goodbye, jackchou00.icu    🚀 A new chapter will begin at <a href="https://jackchou.top">jackchou.top</a>
          </span>
        </div>
        <button class="close-btn" onclick="dismissNotice()">✕</button>
      </div>
    </div>
  `;
  
  
  document.addEventListener('DOMContentLoaded', function() {
    
    document.body.insertAdjacentHTML('afterbegin', noticeHTML);
    
    
    const isEnglish = document.documentElement.lang === 'en' || window.location.pathname.startsWith('/en/');
    const zhNotice = document.querySelector('.zh-notice');
    const enNotice = document.querySelector('.en-notice');
    
    if (isEnglish && enNotice) {
      enNotice.style.display = 'inline';
    } else if (zhNotice) {
      zhNotice.style.display = 'inline';
    }
    
    
    const notice = document.getElementById('domain-migration-notice');
    if (notice) {
      notice.classList.add('show');
      document.body.classList.add('notice-shown');
    }
  });
  
  
  window.dismissNotice = function() {
    const notice = document.getElementById('domain-migration-notice');
    if (notice) {
      notice.style.display = 'none';
      document.body.classList.remove('notice-shown');
      localStorage.setItem('domain-migration-dismissed', 'true');
    }
  };
})();
</script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4dc1311d77d6840123f21aa2f8a31c84";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><meta property="og:url" content="https://jackchou.top/posts/gainmap-image-intro/">
  <meta property="og:site_name" content="🏡JacksBlog">
  <meta property="og:title" content="HDR 图像格式解析（一）：Gainmap 的基本概念">
  <meta property="og:description" content="这是 HDR 静态图像格式解析系列的第一篇，旨在介绍一种新的图像格式：Gainmap 的基本概念，通过增加一层增益图和元数据的方式，实现 HDR 静态图像的存储。其特点在于，是一种与 SDR 兼容性很好，相对亮度的 HDR 格式。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-19T00:00:00+08:00">
    <meta property="article:modified_time" content="2025-08-19T00:00:00+08:00">
    <meta property="article:tag" content="Colour">
    <meta property="article:tag" content="HDR">
    <meta property="article:tag" content="Gainmap">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HDR 图像格式解析（一）：Gainmap 的基本概念">
<meta name="twitter:description" content="这是 HDR 静态图像格式解析系列的第一篇，旨在介绍一种新的图像格式：Gainmap 的基本概念，通过增加一层增益图和元数据的方式，实现 HDR 静态图像的存储。其特点在于，是一种与 SDR 兼容性很好，相对亮度的 HDR 格式。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "文章 🌳",
      "item": "https://jackchou.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "HDR 图像格式解析（一）：Gainmap 的基本概念",
      "item": "https://jackchou.top/posts/gainmap-image-intro/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HDR 图像格式解析（一）：Gainmap 的基本概念",
  "name": "HDR 图像格式解析（一）：Gainmap 的基本概念",
  "description": "这是 HDR 静态图像格式解析系列的第一篇，旨在介绍一种新的图像格式：Gainmap 的基本概念，通过增加一层增益图和元数据的方式，实现 HDR 静态图像的存储。其特点在于，是一种与 SDR 兼容性很好，相对亮度的 HDR 格式。",
  "keywords": [
    "Colour", "HDR", "Gainmap"
  ],
  "articleBody": "两张 JPG 现在的手机基本都支持了 Gainmap 照片，OPPO 一直提到的 ProXDR 照片便是指 Gainmap，以前是自有格式，后来使用的是谷歌的 UltraHDR。\n如果你在二进制模式的文件中寻找 JPG 的起始符 FF D8 和结束符 FF D9，会发现这种图像文件中能找到不止一张 JPG 图片，一般可以在第一个结束符后面，紧接着找到下一个起始符，直接在字节流中把它们分开，保存成两个 JPG 文件，便可看到主图和增益图，同时，在增益图的 APPn 标记段中，可以以 XMP 形式找到解码增益图需要的一些元数据，比如 Min，Max，Gamma 和 Offset。\n比较有意思的是，适马最新的相机 Sigma BF 的直出 JPG 也是这种格式，是第一台能够直出 HDR JPG 图片的相机，能在传统派相机行业里看到这种格式是非常惊喜的。\n这是一张由 OPPO Find X6 Pro 拍摄的，符合 UltraHDR 标准的 JPG 照片，华为练秋湖的这栋楼当时阳光从一侧照亮，形成较大的明暗反差。其中左侧的是第一段 JPG，即 UltraHDR 中的主要图像，是一个普通的 SDR 图像，在不兼容 UltraHDR 的播放器，或显示器不兼容 HDR 时，看到的就是该图像，中间为第二段 JPG，即 Gainmap，由于并不是为直接显示而设计的，此处只是将其按照 RGB 渲染，当作一种“可视化”的手段。\n{ \"Version\": 1.0, \"GainMapMin\": 0, \"GainMapMax\": 2.16048, \"Gamma\": 1, \"OffsetSDR\": 0, \"OffsetHDR\": 0, \"HDRCapacityMin\": 0, \"HDRCapacityMax\": 2.16048, \"BaseRenditionIsHDR\": false, \"OplusScale\": 4.47065 } 这是从第二段 JPG 的 APP1 中获得的元数据，增益图中的像素值需要按照元数据计算出一个“倍率”，来获得右侧的 HDR 效果。其中 OplusScale 是 OPPO 自己的一个字段，不清楚具体用途是什么，其余都是 UltraHDR 的标准元素。\n右侧是合成的 HDR 效果，为了方便展示，该图实际上是解码之后，再以 PQ 编码在一起的纯 HDR AVIF 图像，并不是 UltraHDR，在峰值亮度允许的情况下，显示效果是一致的，否则会有所不同，下图是 UltraHDR 的原始版本，文件体积较大，可能加载慢一点。\n记录差异 Gainmap 记录的是 SDR 和 HDR 之间的差异，理解这一点可以从很多角度入手。\n现在有一个图片，在 HDR 设备上，希望画面上的某些区域的亮度能够超过原先 SDR 的白点，做到高亮的效果。在不改动 SDR 显示效果的情况下，用另一幅图像标记出需要提亮的区域和提亮的程度，然后把 SDR 和差异图编码在一起。\n或者现有一个 HDR 图片，但由于这种图片格式本身的兼容性，以及依靠设备下变换到 SDR 的兼容性都不够好，可以先下变换出一个满意的 SDR 图片，把它编码成传统、成熟的格式，然后用另一幅图像记录下原图和 SDR 图片的区别，编码到一起。\n总之，Gainmap 本身只记录差异，你可以把一个有画面内容的图片当作 Gainmap，封装到一个纯色的主图边上，创造一个只有解码成功的 HDR 设备才能看到画面的东西。\n上面的两个例子都是主图为 SDR 的情况，实际上，主图也可以是 HDR 的，通过 Gainmap 记录如何下变换到 SDR，但绝大多数情况下，都是使用 SDR 主图，这样即使解码器不支持，也可以当作普通的 SDR 图片来显示，有最好的兼容性。\n因此，Gainmap 只是一种编码手段，在有了 HDR 和 SDR 图像之后进行编码的时候使用，而不应当将 Gainmap 本身看作一种调节图像的方法。比如说，在 Gainmap 上做某种操作来让图片更亮，或者在没有 HDR 图像的情况下以某种算法生成一个 Gainmap 出来，使一个本身是 SDR 的图上变换到 HDR。\nGainmap 的计算 关于如何生成 Gainmap，我觉得读者更应参考具体平台的文档，尤其是 Gainmap 这样标准繁多的新事物，本文更多只介绍 Gainmap 的概念。\n比较推荐的几个文档和网页：\n谷歌的 UltraHDR，目前该格式是最为广泛使用的一种 HDR 双层格式，v1.1 版本还兼容了 ISO 21496-1 国际标准。如果您还是安卓平台的开发者，更是不得不看了。 Adobe 的 Gain map，Adobe 也是该格式的大力推动者，它推出的一款 Demo APP 是浏览各种 HDR 图片最方便的方法，该页面中还有一份详细的 Spec 文档，里面有一些很有参考价值的笔记。 在生成 Gainmap 前，你需要准备在线性光空间的 SDR 和 HDR 图像，比如规定 SDR 图像的像素值范围是 0-1，HDR 与之尺度对齐，但允许负数或超过 1 的数。这是因为 SDR 和 HDR 需要拥有相同的基色（比如 P3），如果基色范围选的比较小（比如 sRGB），或者 HDR 图像的色域特别广，就会出现负值，无需担心，Gainmap 是能够记录负值的。超过 1 的部分则是 HDR 本身的特征。\n$$\rG = \\log_2 \\frac{\\text{HDR}+k_{\\text{hdr}}}{\\text{SDR}+k_{\\text{sdr}}}\r$$其中，两个 k 是偏移量，用于将可能的负数偏移到正数，确保这个对数运算是有意义的。\n然后，找到 G 的最大值和最小值，用于将 G 映射到 0-1 范围内。为了提高可靠性，可以选择排除一小部分最小和最大值之后再选，然后再裁切掉超出 0-1 的值。\n这样，你就得到了一个 0-1 范围内的图像，可以对其施加 Gamma 来提高量化的效果，并选择一个合适的位深（通常是 8 bit）和编码方式将其编码。\n同时，还要把偏移量、最大值、最小值、Gamma 等元数据一并按规范编码。\n单通道与三通道 为了节约空间，Gainmap 可以是灰度的，比如大部分安卓手机正在采用的，OPPO X8 Ultra 上的“原彩 ProXDR”照片指的便是升级到了三通道。\n灰度 Gainmap 和三通道的彩色 Gainmap 区别主要在于 SDR 和 HDR 之间的关联或自由度。\n三通道的 Gainmap 几乎完全自由，HDR 和 SDR 可以没有联系，Gainmap 可以在两个任意的点之间建立联系。但单通道的 Gainmap 要求 SDR 和 HDR 图像中的 RGB 像素值具有相同的比例，或者说在空间坐标系中，与原点位于一条直线上。\n在不约束 SDR 图像的情况下，两种 Gainmap 能达到的 HDR 色域容积是一样的，但三通道时，允许更自由的下变换方法，单通道的增益图则只能在亮度方面做下变换。而在保持相同 SDR 图像的时候，三通道的 Gainmap 能够更精细的控制 HDR 图像。\n有什么影响？根据 Bezold–Brücke 和 Hunt 效应，当亮度变化时，颜色的色相和彩度都会随之变化，单通道 Gainmap 仅能对亮度控制，保证 HDR 不变，下变换到 SDR 就受到限制，保持 SDR 的效果不变，能存储的 HDR 内容就受到限制，它们的色相（指的是 RGB 空间上的，而非感知）不能不同。\n另外，在量化精度方面，三通道的 Gainmap 也具有一定的优势，通过元数据中，记录三个通道各自的最大和最小值，能够控制每个通道的归一化时的压缩程度及 Gamma。\n对 Gainmap 的压缩 当对 Gainmap 进行压缩，尤其是降分辨率操作（大部分手机都会降分辨率至原来的 50% 长宽），可能会出现与主图无法对齐的现象，导致合成出来的 HDR 图片产生伪色、断层。同样的，对主图的压缩也可能导致与 Gainmap 无法对齐，尤其是高频部分，在点光源等典型 HDR 场景会更明显。\n压缩 Gainmap 的方法和压缩普通图像基本相同，比如 JPG，JPEG XL，HEIC 这些，但 Gainmap 又和普通图像不太一样，因此有人提出了一些特别针对性的方法，最简单的有对 Gainmap 额外应用一个 Gamma 函数，也有一些用到机器学习的方法，比如这篇使用 MLP 来压缩 Gainmap 的文章。\nT. D. Canham, S. Tedla, M. J. Murdoch, and M. S. Brown, “Gain-MLP: Improving HDR Gain Map Encoding via a Lightweight MLP,” Mar. 14, 2025, arXiv:2503.11883.\n其它的封装方法 JPEG XL 是最新的一种 JPEG 格式，拥有很高的压缩率，并且支持很多新特性，其中就包括双层格式。\nHEIF 和 AVIF 也支持双层格式，是以附加图的形式保存在元数据中，比如 iPhone 拍摄的 HDR 图片就是以该形式保存，解码的时候需要先找到对应的 Tag，再提取 Gainmap，开启了高效存储的 OPPO 手机拍摄的照片也是以 HEIF 存储，但 Tag 不相同。\nTIFF 也是可以把多个帧保存在一起的，因此也可以保存 Gainmap。\n在 Adobe Camera Raw 或者 Lightroom 输出 HDR 图片时，选择“最大兼容”后，导出的就是以上格式。\n小结和未来 Gainmap 已经被广泛的采用，它向前兼容，各种新封装也广泛支持，很方便的存储下变换结果。\n但从 HDR 的角度来看，它像 SDR 一样是相对亮度的，但又受到 HDR 峰值亮度的制约，用户调整显示屏亮度时，显示效果可能会明显变化。如果显示屏的 HDR 能力不足 Gainmap 中规定的最大值，这些中间情况的色调映射下变换具体实践也比较模糊。\n另外，存储 Gainmap 需要两张 8 Bit 图像，在压缩效率方面可能不如单一 10 或 12 Bit 的纯 HDR 图像。多数 JPG 格式的云服务（CDN 上的图像压缩，社交媒体的审查）还可能会错过 Gainmap，因为它位于第一个 JPG 流结束之后。\n接下来，我会写一些常见的 Gainmap 格式的特点和使用，并整理和提供一些 Python 代码。\n",
  "wordCount" : "440",
  "inLanguage": "zh-cn",
  "datePublished": "2025-08-19T00:00:00+08:00",
  "dateModified": "2025-08-19T00:00:00+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jackchou.top/posts/gainmap-image-intro/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "🏡JacksBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jackchou.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jackchou.top/" accesskey="h" title="🏡JacksBlog (Alt + H)">🏡JacksBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://jackchou.top/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jackchou.top/posts/" title="文章 🌳">
                    <span>文章 🌳</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/photos/" title="照片 📷">
                    <span>照片 📷</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/tags/" title="标签 🏷️">
                    <span>标签 🏷️</span>
                </a>
            </li>
            <li>
                <a href="https://jackchou.top/about/" title="关于 😼">
                    <span>关于 😼</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      HDR 图像格式解析（一）：Gainmap 的基本概念
    </h1>
    <div class="post-description">
      这是 HDR 静态图像格式解析系列的第一篇，旨在介绍一种新的图像格式：Gainmap 的基本概念，通过增加一层增益图和元数据的方式，实现 HDR 静态图像的存储。其特点在于，是一种与 SDR 兼容性很好，相对亮度的 HDR 格式。
    </div>
    <div class="post-meta"><span title='2025-08-19 00:00:00 +0800 +0800'>2025.08.19</span>&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="https://jackchou.top/en/posts/gainmap-image-intro/">En</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%a4%e5%bc%a0-jpg" aria-label="两张 JPG">两张 JPG</a></li>
                <li>
                    <a href="#%e8%ae%b0%e5%bd%95%e5%b7%ae%e5%bc%82" aria-label="记录差异">记录差异</a></li>
                <li>
                    <a href="#gainmap-%e7%9a%84%e8%ae%a1%e7%ae%97" aria-label="Gainmap 的计算">Gainmap 的计算</a></li>
                <li>
                    <a href="#%e5%8d%95%e9%80%9a%e9%81%93%e4%b8%8e%e4%b8%89%e9%80%9a%e9%81%93" aria-label="单通道与三通道">单通道与三通道</a></li>
                <li>
                    <a href="#%e5%af%b9-gainmap-%e7%9a%84%e5%8e%8b%e7%bc%a9" aria-label="对 Gainmap 的压缩">对 Gainmap 的压缩</a></li>
                <li>
                    <a href="#%e5%85%b6%e5%ae%83%e7%9a%84%e5%b0%81%e8%a3%85%e6%96%b9%e6%b3%95" aria-label="其它的封装方法">其它的封装方法</a></li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93%e5%92%8c%e6%9c%aa%e6%9d%a5" aria-label="小结和未来">小结和未来</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="两张-jpg">两张 JPG<a hidden class="anchor" aria-hidden="true" href="#两张-jpg">#</a></h2>
<p>现在的手机基本都支持了 Gainmap 照片，OPPO 一直提到的 ProXDR 照片便是指 Gainmap，以前是自有格式，后来使用的是谷歌的 UltraHDR。</p>
<p>如果你在二进制模式的文件中寻找 JPG 的起始符 <code>FF D8</code> 和结束符 <code>FF D9</code>，会发现这种图像文件中能找到不止一张 JPG 图片，一般可以在第一个结束符后面，紧接着找到下一个起始符，直接在字节流中把它们分开，保存成两个 JPG 文件，便可看到主图和增益图，同时，在增益图的 APPn 标记段中，可以以 XMP 形式找到解码增益图需要的一些元数据，比如 Min，Max，Gamma 和 Offset。</p>
<p>比较有意思的是，适马最新的相机 Sigma BF 的直出 JPG 也是这种格式，是第一台能够直出 HDR JPG 图片的相机，能在传统派相机行业里看到这种格式是非常惊喜的。</p>
<p><img alt="主图、增益图和 HDR 效果图" loading="lazy" src="https://img.jackchou.top/jack-img/2025/08/7b707c62cd1a652311d0dc9e86e18a5d.avif"></p>
<p>这是一张由 OPPO Find X6 Pro 拍摄的，符合 UltraHDR 标准的 JPG 照片，华为练秋湖的这栋楼当时阳光从一侧照亮，形成较大的明暗反差。其中左侧的是第一段 JPG，即 UltraHDR 中的主要图像，是一个普通的 SDR 图像，在不兼容 UltraHDR 的播放器，或显示器不兼容 HDR 时，看到的就是该图像，中间为第二段 JPG，即 Gainmap，由于并不是为直接显示而设计的，此处只是将其按照 RGB 渲染，当作一种“可视化”的手段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;Version&#34;</span>: <span style="color:#ae81ff">1.0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;GainMapMin&#34;</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;GainMapMax&#34;</span>: <span style="color:#ae81ff">2.16048</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;Gamma&#34;</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;OffsetSDR&#34;</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;OffsetHDR&#34;</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;HDRCapacityMin&#34;</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;HDRCapacityMax&#34;</span>: <span style="color:#ae81ff">2.16048</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;BaseRenditionIsHDR&#34;</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;OplusScale&#34;</span>: <span style="color:#ae81ff">4.47065</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这是从第二段 JPG 的 APP1 中获得的元数据，增益图中的像素值需要按照元数据计算出一个“倍率”，来获得右侧的 HDR 效果。其中 <code>OplusScale</code> 是 OPPO 自己的一个字段，不清楚具体用途是什么，其余都是 UltraHDR 的标准元素。</p>
<p>右侧是合成的 HDR 效果，为了方便展示，该图实际上是解码之后，再以 PQ 编码在一起的纯 HDR AVIF 图像，并不是 UltraHDR，在峰值亮度允许的情况下，显示效果是一致的，否则会有所不同，下图是 UltraHDR 的原始版本，文件体积较大，可能加载慢一点。</p>
<p><img alt="UltraHDR 格式的原图" loading="lazy" src="https://img.jackchou.top/jack-img/2025/08/ff11ed6494bb8adfb876afb8db615c9a.jpg"></p>
<h2 id="记录差异">记录差异<a hidden class="anchor" aria-hidden="true" href="#记录差异">#</a></h2>
<p>Gainmap 记录的是 SDR 和 HDR 之间的差异，理解这一点可以从很多角度入手。</p>
<p>现在有一个图片，在 HDR 设备上，希望画面上的某些区域的亮度能够超过原先 SDR 的白点，做到高亮的效果。在不改动 SDR 显示效果的情况下，用另一幅图像标记出需要提亮的区域和提亮的程度，然后把 SDR 和差异图编码在一起。</p>
<p>或者现有一个 HDR 图片，但由于这种图片格式本身的兼容性，以及依靠设备下变换到 SDR 的兼容性都不够好，可以先下变换出一个满意的 SDR 图片，把它编码成传统、成熟的格式，然后用另一幅图像记录下原图和 SDR 图片的区别，编码到一起。</p>
<p>总之，Gainmap 本身只记录差异，你可以把一个有画面内容的图片当作 Gainmap，封装到一个纯色的主图边上，创造一个只有解码成功的 HDR 设备才能看到画面的东西。</p>
<p>上面的两个例子都是主图为 SDR 的情况，实际上，主图也可以是 HDR 的，通过 Gainmap 记录如何下变换到 SDR，但绝大多数情况下，都是使用 SDR 主图，这样即使解码器不支持，也可以当作普通的 SDR 图片来显示，有最好的兼容性。</p>
<p>因此，Gainmap 只是一种编码手段，在有了 HDR 和 SDR 图像之后进行编码的时候使用，而不应当将 Gainmap 本身看作一种调节图像的方法。比如说，在 Gainmap 上做某种操作来让图片更亮，或者在没有 HDR 图像的情况下以某种算法生成一个 Gainmap 出来，使一个本身是 SDR 的图上变换到 HDR。</p>
<h2 id="gainmap-的计算">Gainmap 的计算<a hidden class="anchor" aria-hidden="true" href="#gainmap-的计算">#</a></h2>
<blockquote>
<p>关于如何生成 Gainmap，我觉得读者更应参考具体平台的文档，尤其是 Gainmap 这样标准繁多的新事物，本文更多只介绍 Gainmap 的概念。</p>
</blockquote>
<p>比较推荐的几个文档和网页：</p>
<ul>
<li>谷歌的 <a href="https://developer.android.com/media/platform/hdr-image-format">UltraHDR</a>，目前该格式是最为广泛使用的一种 HDR 双层格式，v1.1 版本还兼容了 ISO 21496-1 国际标准。如果您还是安卓平台的开发者，更是不得不看了。</li>
<li>Adobe 的 <a href="https://helpx.adobe.com/camera-raw/using/gain-map.html">Gain map</a>，Adobe 也是该格式的大力推动者，它推出的一款 Demo APP 是浏览各种 HDR 图片最方便的方法，该页面中还有一份详细的 Spec 文档，里面有一些很有参考价值的笔记。</li>
</ul>
<p>在生成 Gainmap 前，你需要准备在<strong>线性光空间</strong>的 SDR 和 HDR 图像，比如规定 SDR 图像的像素值范围是 0-1，HDR 与之尺度对齐，但允许负数或超过 1 的数。这是因为 SDR 和 HDR 需要拥有相同的基色（比如 P3），如果基色范围选的比较小（比如 sRGB），或者 HDR 图像的色域特别广，就会出现负值，无需担心，Gainmap 是能够记录负值的。超过 1 的部分则是 HDR 本身的特征。</p>
$$
G = \log_2 \frac{\text{HDR}+k_{\text{hdr}}}{\text{SDR}+k_{\text{sdr}}}
$$<p>其中，两个 k 是偏移量，用于将可能的负数偏移到正数，确保这个对数运算是有意义的。</p>
<p>然后，找到 G 的最大值和最小值，用于将 G 映射到 0-1 范围内。为了提高可靠性，可以选择排除一小部分最小和最大值之后再选，然后再裁切掉超出 0-1 的值。</p>
<p>这样，你就得到了一个 0-1 范围内的图像，可以对其施加 Gamma 来提高量化的效果，并选择一个合适的位深（通常是 8 bit）和编码方式将其编码。</p>
<p>同时，还要把偏移量、最大值、最小值、Gamma 等元数据一并按规范编码。</p>
<h2 id="单通道与三通道">单通道与三通道<a hidden class="anchor" aria-hidden="true" href="#单通道与三通道">#</a></h2>
<p>为了节约空间，Gainmap 可以是灰度的，比如大部分安卓手机正在采用的，OPPO X8 Ultra 上的“原彩 ProXDR”照片指的便是升级到了三通道。</p>
<p>灰度 Gainmap 和三通道的彩色 Gainmap 区别主要在于 SDR 和 HDR 之间的关联或自由度。</p>
<p>三通道的 Gainmap 几乎完全自由，HDR 和 SDR 可以没有联系，Gainmap 可以在两个任意的点之间建立联系。但单通道的 Gainmap 要求 SDR 和 HDR 图像中的 RGB 像素值具有相同的比例，或者说在空间坐标系中，与原点位于一条直线上。</p>
<p>在不约束 SDR 图像的情况下，两种 Gainmap 能达到的 HDR 色域容积是一样的，但三通道时，允许更自由的下变换方法，单通道的增益图则只能在亮度方面做下变换。而在保持相同 SDR 图像的时候，三通道的 Gainmap 能够更精细的控制 HDR 图像。</p>
<p>有什么影响？根据 Bezold–Brücke 和 Hunt 效应，当亮度变化时，颜色的色相和彩度都会随之变化，单通道 Gainmap 仅能对亮度控制，保证 HDR 不变，下变换到 SDR 就受到限制，保持 SDR 的效果不变，能存储的 HDR 内容就受到限制，它们的色相（指的是 RGB 空间上的，而非感知）不能不同。</p>
<p>另外，在量化精度方面，三通道的 Gainmap 也具有一定的优势，通过元数据中，记录三个通道各自的最大和最小值，能够控制每个通道的归一化时的压缩程度及 Gamma。</p>
<h2 id="对-gainmap-的压缩">对 Gainmap 的压缩<a hidden class="anchor" aria-hidden="true" href="#对-gainmap-的压缩">#</a></h2>
<p>当对 Gainmap 进行压缩，尤其是降分辨率操作（大部分手机都会降分辨率至原来的 50% 长宽），可能会出现与主图无法对齐的现象，导致合成出来的 HDR 图片产生伪色、断层。同样的，对主图的压缩也可能导致与 Gainmap 无法对齐，尤其是高频部分，在点光源等典型 HDR 场景会更明显。</p>
<p>压缩 Gainmap 的方法和压缩普通图像基本相同，比如 JPG，JPEG XL，HEIC 这些，但 Gainmap 又和普通图像不太一样，因此有人提出了一些特别针对性的方法，最简单的有对 Gainmap 额外应用一个 Gamma 函数，也有一些用到机器学习的方法，比如这篇使用 MLP 来压缩 Gainmap 的文章。</p>
<blockquote>
<p>T. D. Canham, S. Tedla, M. J. Murdoch, and M. S. Brown, “Gain-MLP: Improving HDR Gain Map Encoding via a Lightweight MLP,” Mar. 14, 2025, arXiv:2503.11883.</p>
</blockquote>
<h2 id="其它的封装方法">其它的封装方法<a hidden class="anchor" aria-hidden="true" href="#其它的封装方法">#</a></h2>
<p>JPEG XL 是最新的一种 JPEG 格式，拥有很高的压缩率，并且支持很多新特性，其中就包括双层格式。</p>
<p>HEIF 和 AVIF 也支持双层格式，是以附加图的形式保存在元数据中，比如 iPhone 拍摄的 HDR 图片就是以该形式保存，解码的时候需要先找到对应的 Tag，再提取 Gainmap，开启了高效存储的 OPPO 手机拍摄的照片也是以 HEIF 存储，但 Tag 不相同。</p>
<p>TIFF 也是可以把多个帧保存在一起的，因此也可以保存 Gainmap。</p>
<p>在 Adobe Camera Raw 或者 Lightroom 输出 HDR 图片时，选择“最大兼容”后，导出的就是以上格式。</p>
<h2 id="小结和未来">小结和未来<a hidden class="anchor" aria-hidden="true" href="#小结和未来">#</a></h2>
<p>Gainmap 已经被广泛的采用，它向前兼容，各种新封装也广泛支持，很方便的存储下变换结果。</p>
<p>但从 HDR 的角度来看，它像 SDR 一样是相对亮度的，但又受到 HDR 峰值亮度的制约，用户调整显示屏亮度时，显示效果可能会明显变化。如果显示屏的 HDR 能力不足 Gainmap 中规定的最大值，这些中间情况的色调映射下变换具体实践也比较模糊。</p>
<p>另外，存储 Gainmap 需要两张 8 Bit 图像，在压缩效率方面可能不如单一 10 或 12 Bit 的纯 HDR 图像。多数 JPG 格式的云服务（CDN 上的图像压缩，社交媒体的审查）还可能会错过 Gainmap，因为它位于第一个 JPG 流结束之后。</p>
<p>接下来，我会写一些常见的 Gainmap 格式的特点和使用，并整理和提供一些 Python 代码。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jackchou.top/tags/colour/">Colour</a></li>
      <li><a href="https://jackchou.top/tags/hdr/">HDR</a></li>
      <li><a href="https://jackchou.top/tags/gainmap/">Gainmap</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://jackchou.top/">🏡JacksBlog</a></span> · 
        my friends&rsquo; websites: <a href="https://zhxwu.com/">zhxwu.com</a>, <a href="https://ylqian.com/">ylqian.com</a> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><div style="text-align: center; margin-top: 10px; margin-bottom: 20px; width: 100%; display: flex; justify-content: center;">
    <img src="https://visitor-badge.laobi.icu/badge?page_id=jacksblog" alt="visitors" style="max-width: 120px; height: auto;" />
</div>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
